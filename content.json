{"meta":{"title":"LiuYang's blog","subtitle":"探索，分享，创新——追求卓越","description":"探索，分享，创新——追求卓越","author":"刘阳","url":"https://handsomeliuyang.github.io"},"pages":[{"title":"关于","date":"2018-03-12T11:28:09.000Z","updated":"2018-03-14T09:57:52.000Z","comments":false,"path":"about/index.html","permalink":"https://handsomeliuyang.github.io/about/index.html","excerpt":"","text":""},{"title":"类别","date":"2018-03-12T11:28:09.000Z","updated":"2018-03-14T09:57:42.000Z","comments":false,"path":"categories/index.html","permalink":"https://handsomeliuyang.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-03-12T11:26:58.000Z","updated":"2018-03-14T09:58:12.000Z","comments":false,"path":"tags/index.html","permalink":"https://handsomeliuyang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"DiyReact学习之路","slug":"DiyReact学习之路","date":"2018-08-07T13:15:35.000Z","updated":"2018-08-21T02:33:44.932Z","comments":true,"path":"2018/08/07/DiyReact学习之路/","link":"","permalink":"https://handsomeliuyang.github.io/2018/08/07/DiyReact学习之路/","excerpt":"","text":"DiyReact的功能React的核心点： 组件（Component） Virtual Dom JSX Props &amp; State 核心的渲染的Api：1ReactDOM.render(element, container[, callback]) 在不考虑性能，调试，扩展性的情况下，实现上面React的核心功能，相同Api，仅仅只需要几百行的代码。在此过程中，能真正的去理解其中的关键概念。 Element,Component,Dom下面是React最简单的写法：12345678// 最简单的elementconst element = &#123; type: \"div\", props: &#123; id: \"foo\" &#125;&#125;;diyreact.render(element, document.getElementById(\"root\")); 在此demo中，就是把element转化为dom显示出来。在React里，我们不直接操作Dom元素，我们操作的是Dom的抽象层即Element。 Elements Describe the Tree An element is a plain object describing a component instance or DOM node and its desired properties. 即通过Element用来表示组件与Dom结点及他们的属性，整体构成一个树型结构，DiyReact.Element的定义非常的简单，如下所示：12345678&#123; type: \"\", // 类型，可以为Dom元素，或Component类型，如Button props: &#123; children:[ // element类型的children ], xxx: xxx // 此element的属性列表 &#125;&#125; 如下面的Element：1234567891011const element = &#123; type: \"div\", props: &#123; id: \"container\", children: [ &#123; type: \"input\", props: &#123; value: \"foo\", type: \"text\" &#125; &#125;, &#123; type: \"a\", props: &#123; href: \"/bar\" &#125; &#125;, &#123; type: \"span\", props: &#123;&#125; &#125; ] &#125;&#125;; 其所描述的Dom：12345&lt;div id=\"container\"&gt; &lt;input value=\"foo\" type=\"text\"&gt; &lt;a href=\"/bar\"&gt;&lt;/a&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 如上所示，render()方法就是利用Dom的Api，把Element树转换为对应的Dom树：1234567891011121314151617181920212223242526272829export function render(element, parentDom) &#123; const &#123;type, props&#125; = element; // 创建Dom的Element const isTextElement = type === \"TEXT ELEMENT\"; const dom = isTextElement ? document.createTextNode(\"\") : document.createElement(type); // 读取element里的onXXX属性，当事件处理 const isListener = name =&gt; name.startsWith(\"on\"); Object.keys(props).filter(isListener).forEach(name =&gt; &#123; const eventType = name.toLowerCase().substring(2); dom.addEventListener(eventType, props[name]); &#125;); // element里除onXXX与children属性外，都当属性对待 const isAttribute = name =&gt; !isListener(name) &amp;&amp; name != \"children\"; Object.keys(props).filter(isAttribute).forEach(name =&gt; &#123; dom[name] = props[name]; &#125;); // 递归render children const childElements = props.children || []; childElements.forEach(childElement =&gt; render(childElement, dom)); // 添加到parentDom parentDom.appendChild(dom);&#125; createElement与JSX直接使用Element来描述Dom元素，其可读性很差，如下所示：1234567891011const element = &#123; type: \"div\", props: &#123; id: \"container\", children: [ &#123; type: \"input\", props: &#123; value: \"foo\", type: \"text\" &#125; &#125;, &#123; type: \"a\", props: &#123; href: \"/bar\" children: [&#123; type: \"TEXT ELEMENT\", props: &#123; nodeValue: \"bar\" &#125; &#125;]&#125; &#125;, &#123; type: \"span\", props: &#123;&#125; &#125; ] &#125;&#125;; 而使用JSX来表示的话，可读性就能提升很多，如下所示：12345678/**@jsx diyreact.createElement **/const element = ( &lt;div id=\"container\"&gt; &lt;input value=\"foo\" type=\"text\"/&gt; &lt;a href=\"/bar\"&gt;bar&lt;/a&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;); 以上的JSX语法，浏览器无法识别，需要通过babel进行预处理，通过babel的插件transform-react-jsx把JSX转换为如下代码：12345678910111213/**@jsx diyreact.createElement **/const element = diyreact.createElement( \"div\", &#123; id: \"container\" &#125;, diyreact.createElement(\"input\", &#123; value: \"foo\", type: \"text\" &#125;), diyreact.createElement( \"a\", &#123; href: \"/bar\" &#125;, \"bar\" ), diyreact.createElement(\"span\", null)); 增加JSX后的整体流程如下所示： 对应的createElement代码，非常简单：12345678910111213141516const TEXT_ELEMENT = \"TEXT ELEMENT\";export function createElement(type, config, ...args) &#123; const props = Object.assign(&#123;&#125;, config); const hasChildren = args.length &gt; 0; const rawChildren = hasChildren ? [].concat(...args) : []; props.children = rawChildren .filter(c =&gt; c != null &amp;&amp; c !== false) .map(c =&gt; c instanceof Object ? c : createTextElement(c)); return &#123; type, props &#125;;&#125;function createTextElement(value) &#123; return createElement(TEXT_ELEMENT, &#123; nodeValue: value &#125;);&#125; babel的插件transform-react-jsx的做的非常通用，通用注解，可以修改默认的React.createElement函数，可以通过babel-online测试 // TODO-ly render()每次都是从root结点开始进行对比，setState()是从哪个当前这个结点开始，但整体逻辑是一样的 ComponentReact.render()函数里的element的范围很广，可以是Object，Function，Component，但只有Component才会有相应的lifecycle, states等等。12345678910class Component &#123; constructor(props) &#123; this.props = props; this.state = this.state || &#123;&#125;; &#125; setState(partialState) &#123; // 更新逻辑 &#125;&#125; 更多细节大家可以查看：Didact: Components and State 1234567891011/** @jsx diyreact.createElement **/class App extends diyreact.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;DiyReact的学习过程&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;diyreact.render(&lt;App /&gt;, document.getElementById(\"root\")); 其把JSX转换后的代码：123456789101112131415/** @jsx diyreact.createElement **/class App extends diyreact.Component &#123; render() &#123; return diyreact.createElement( \"div\", null, diyreact.createElement( \"h1\", null, \"DiyReact\\u7684\\u5B66\\u4E60\\u8FC7\\u7A0B\" ) ); &#125;&#125;diyreact.render(diyreact.createElement(App, null), document.getElementById(\"root\")); 其对应的Element Tree与Virtual Dom Tree: Instance，reconciliation与Virtual Dom上述的render()函数，把element转为Dom元素，每次调用render()函数时，都会创建全新的dom元素，即使用element完全一致，都不会进行复用。如下所示：123const element = &lt;div&gt;Foo&lt;/div&gt;;render(element, document.getElementById(\"root\"));render(element, document.getElementById(\"root\")); 在React里，求两个Elements Tree的过程称为”reconciliation“，为了复用与对比，我们需要保存一个与之对应的对象树：A Virtual Dom。 这个Virtual Dom的”nodes”应该是什么对象？由于如下原因，我们无法复用element对象： 此node对象，需要关联其对应的dom对象，但elements树应该是不可变的 无法支持Component，因为每个Component都有自己的state对象 引入React的新概念：Instances。此Instances就表示这个Virtual Dom Tree，其中instance表示已经render到dom的对象。定义如下：1instance = &#123;element, dom, childInstances&#125;; 每个element，每个Dom节点都对应一个instance对象，我们的目标是尽可能的减少此instances的创建与销毁。 Element，Instances，Dom的关系图： Component的setState()更新：1234567891011121314151617181920212223242526import &#123; reconcile &#125; from \"./reconciler\";export class Component &#123; constructor(props) &#123; this.props = props; this.state = this.state || &#123;&#125;; &#125; setState(partialState) &#123; this.state = Object.assign(&#123;&#125;, this.state, partialState); updateInstance(this.__internalInstance); &#125;&#125;function updateInstance(internalInstance) &#123; const parentDom = internalInstance.dom.parentNode; const element = internalInstance.element; reconcile(parentDom, internalInstance, element);&#125;export function createPublicInstance(element, internalInstance) &#123; const &#123; type, props &#125; = element; const publicInstance = new type(props); publicInstance.__internalInstance = internalInstance; return publicInstance;&#125; render的核心代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889let rootInstance = null;export function render(element, container) &#123; const prevInstance = rootInstance; const nextInstance = reconcile(container, prevInstance, element); rootInstance = nextInstance;&#125;export function reconcile(parentDom, instance, element) &#123; if (instance == null) &#123; // Create instance const newInstance = instantiate(element); parentDom.appendChild(newInstance.dom); return newInstance; &#125; else if (element == null) &#123; // Remove instance parentDom.removeChild(instance.dom); return null; &#125; else if (instance.element.type !== element.type) &#123; // Replace instance const newInstance = instantiate(element); parentDom.replaceChild(newInstance.dom, instance.dom); return newInstance; &#125; else if (typeof element.type === \"string\") &#123; // Update dom instance updateDomProperties(instance.dom, instance.element.props, element.props); instance.childInstances = reconcileChildren(instance, element); instance.element = element; return instance; &#125; else &#123; //Update composite instance instance.publicInstance.props = element.props; const childElement = instance.publicInstance.render(); const oldChildInstance = instance.childInstance; const childInstance = reconcile(parentDom, oldChildInstance, childElement); instance.dom = childInstance.dom; instance.childInstance = childInstance; instance.element = element; return instance; &#125;&#125;function reconcileChildren(instance, element) &#123; const dom = instance.dom; const childInstances = instance.childInstances; const nextChildElements = element.props.children || []; const newChildInstances = []; const count = Math.max(childInstances.length, nextChildElements.length); for (let i = 0; i &lt; count; i++) &#123; const childInstance = childInstances[i]; const childElement = nextChildElements[i]; const newChildInstance = reconcile(dom, childInstance, childElement); newChildInstances.push(newChildInstance); &#125; return newChildInstances.filter(instance =&gt; instance != null);&#125;function instantiate(element) &#123; const &#123; type, props &#125; = element; const isDomElement = typeof type === \"string\"; if (isDomElement) &#123; // Instantiate DOM element const isTextElement = type === TEXT_ELEMENT; const dom = isTextElement ? document.createTextNode(\"\") : document.createElement(type); updateDomProperties(dom, [], props); const childElements = props.children || []; const childInstances = childElements.map(instantiate); const childDoms = childInstances.map(childInstance =&gt; childInstance.dom); childDoms.forEach(childDom =&gt; dom.appendChild(childDom)); const instance = &#123; dom, element, childInstances &#125;; return instance; &#125; else &#123; // Instantiate component element const instance = &#123;&#125;; const publicInstance = createPublicInstance(element, instance); const childElement = publicInstance.render(); const childInstance = instantiate(childElement); const dom = childInstance.dom; Object.assign(instance, &#123; dom, element, childInstance, publicInstance &#125;); return instance; &#125;&#125; diyreact的reconciliation算法比较简单，只有当position与type都相同的情况下，才复用此instance，更新其内部的属性 Fiber上述的reconciliation算法是一个递归算法，当节点数量很大时，整体执行时间比较慢，会一直占用浏览器的main thread，导致动画出现卡顿和用户操作响应不及时。卡顿的理解与Android的卡顿理解是一至的，当一次render()或setState()，触发的reconcile()过程，超过16ms时，就会出现丢帧现象。卡顿demo，如下图所示： 要解决卡顿问题，主要是解决上述的递归调用问题，让递归调用可以被中断，优先去处理animation和UI responsive。 React在16.x.x的解决方案是：把上述的执行过程拆分为很多的工作单元（UnitOfWork），这些很小的工作单元都能在很短的时间内执行完成，同时每两个执工作单元之间可以被中断，让main thread执行更高优先级的任务，如animation，ui responsive。 在DiyReact里的UnitOfWork就是包括当前节点的处理工作： new_type != cur_type：全新创建instance type相等 &amp;&amp; type是string类型：更新属性 type相等 &amp;&amp; type为对象：执行component.render()，更新属性 如果知道当前main thread需要执行更高优先级任务了？利用requestIdleCallback-后台任务调度就可以了解当前main thread是否处于空闲时间，其调用代码：1234567891011render()&#123; updateQueue.push(...); window.requestIdleCallback(performWork);&#125;function performWork(deadline) &#123; // ... while(nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME)&#123; nextUnitOfWork = performUnitOfWork(nextUnitOfWork); &#125; // ...&#125; 该图中的frame#1，frame#2就是两个帧，每个帧的持续时间是(100/60 = 16.66ms)，而在每一帧内部，TASK和redering只花费了一部分时间，并没有占据整个帧，那么这个时候，如图中idle period的部分就是空闲时间，而每一帧中的空闲时间，根据该帧中处理事情的多少，复杂度等，消耗不等，所以空闲时间也不等。 通过deadline.timeRemaining()函数即可知道当前还剩多少idle时间。 要实现这套新的工作单元调度，instance tree的节点instance的结构会要发生变化，如下所示：12345678910111213141516&#123; tag:HOST_COMPONENT|CLASS_COMPONENT, type:\"div\"|Component, // 构建一个树型链表结构 parent: parentFiber, child: childFiber, sibling:null, // 关联第二颗树 alternate: other fiber tree, stateNode:dom|component, props: element.props, partialState: component changed state, // 记录真正变动的节点fiber effectTag:PLACEMENT, effects: []&#125;; 这颗新的树的结点有一个新的名称：Fiber。这个颗也被称为Fiber Tree。 fiber tree的结构： 每两个工作单元之间，可以被更高优先级的任务中断，那就无法使用一颗Fiber Tree，即对应当前的Dom，又进行更新操作。通过上面的alternate可知，有两颗相互关联的Fiber Tree： current tree：与当前的Dom对应，其内容已经渲染到Dom上 work-in-progress：由render()或setState()触发的构建树 方法的调用队列： 更多代码细节，请学习：Didact Fiber: Incremental reconciliation 发布在React的最新版本里，打包工具从webpack，改为rollup。 webpack与rollup基本相同，记住如下差异点： webpack支持code-splitting，同时支持按需加载 Rollup默认基于ES2015模块，把所有的资源放在一起，一次性加载 如何选择？结论： 针对app级别的应该使用Webpack，针对js库级别的应用应该使用Rollup。 更多请参考：Webpack、Rollup相爱相杀的那些事 rollup由于默认基于ES2015模块与语法，而整体DiyReact也是基于ES6开发的，所以配置很简单：123\"scripts\": &#123; \"build:main\": \"rollup src/diyreact.js -f umd -n diyreact -o dist/diyreact.umd.js\"&#125; 具体参数的含义请参考：Command line flags Type of output (amd, cjs, esm, iife, umd)的理解： iife: 立即执行函数 cjs: 遵循CommonJs Module规范的文件输出 amd: 遵循AMD Module规范的文件输出 umd: 支持外链/CommonJs Module/AMD Module规范的文件输出 esm: 将多个遵循ES6 Module的文件编译成1个ES6 Module 在不同场景下的使用情况： 12345678// For browsers:$ rollup main.js --file bundle.js --format iife// For Node.js:$ rollup main.js --file bundle.js --format cjs// For both browsers and Node.js:$ rollup main.js --file bundle.js --format umd --name \"myBundle\" 发布测试为了方便测试生成后的diyreact.js文件，使用的是babel-standalone@6库，在browser下直接运行ES6语法，如下所示：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;html&gt;&lt;head&gt; &lt;script src=&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../dist/diyreact.umd.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot; data-plugins=&quot;transform-react-jsx&quot; data-presets=&quot;es2017,stage-3&quot;&gt; /** @jsx diyreact.createElement **/ const studies = [ &#123; name: &quot;DiyReact的功能&quot;, url: &quot;https://handsomeliuyang.github.io/&quot; &#125;, &#123; name: &quot;createElement与JSX&quot;, url: &quot;https://handsomeliuyang.github.io/&quot; &#125;, &#123; name: &quot;Instance，reconciliation与Virtual Dom&quot;, url: &quot;https://handsomeliuyang.github.io/&quot; &#125;, &#123; name: &quot;Component and State&quot;, url: &quot;https://handsomeliuyang.github.io/&quot; &#125;, &#123; name: &quot;Fiber&quot;, url: &quot;https://handsomeliuyang.github.io/&quot; &#125; ]; class App extends diyreact.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;DiyReact的学习过程&lt;/h1&gt; &lt;ul&gt; &#123; this.props.studies.map(study =&gt; &#123; return &lt;Study name=&#123;study.name&#125; url=&#123;study.url&#125;/&gt;; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ); &#125; &#125; class Study extends diyreact.Component &#123; constructor(props) &#123; super(props); this.state = &#123; likes: Math.ceil(Math.random() * 100) &#125;; &#125; like() &#123; this.setState(&#123; likes: this.state.likes + 1 &#125;); &#125; render() &#123; const &#123; name, url &#125; = this.props; const &#123; likes &#125; = this.state; const likesElement = &lt;span /&gt;; return ( &lt;li&gt; &lt;button onClick=&#123;e =&gt; this.like()&#125;&gt;赞：&#123;likes&#125;️&lt;/button&gt; &lt;a href=&#123;url&#125;&gt;&#123;name&#125;&lt;/a&gt; &lt;/li&gt; ); &#125; &#125; diyreact.render(&lt;App studies=&#123;studies&#125; /&gt;, document.getElementById(&quot;root&quot;)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意： babel-standalone的配置API很少，可以查看其源码：https://github.com/babel/babel-standalone/blob/master/src/index.js babel-standalone不支持env preset，只有es2015, es2016, es2017等等presets,为了支持new Class语法，需要使用es2017 踩过的坑单元测试单元测试必要性这里就不叙述了，选择的是ava单元测试框架，使用过程中的一些问题： es6语法，jsx语法默认不支持？ ava只是一个单元测试框架，需要通过babel来支持es6，jsx等语法的支持，配置如下： 12345678910111213141516171819202122\"ava\": &#123; \"require\": \"babel-register\", \"babel\": \"inherit\" // 继承在package.json里的babel配置&#125;,\"babel\": &#123; \"plugins\": [ [ \"transform-react-jsx\", &#123;&#125; ] ], \"presets\": [ [ \"env\", &#123; \"targets\": &#123; \"node\": \"current\" &#125; &#125; ] ]&#125; 没有browser相关的环境与Api？ 通过browser-env库，可以实现能browser的部分Api进行模拟，如下所示： 1234567891011import browserEnv from 'browser-env';browserEnv(['document']);test.beforeEach(t=&gt;&#123; let root = document.getElementById(\"root\"); if(!root)&#123; root = document.createElement(\"div\"); root.id = \"root\"; document.body.appendChild(root); &#125; t.context.root = root;&#125;); browser-env库没有window.requestIdleCallback等Api？ 为了能进行单元测试，手动给window对象注入requestIdleCallback()实现，当然这里是假实现，如下所示： 12345678window.requestIdleCallback = function(task)&#123; function timeRemaining()&#123; return 2; &#125; task(&#123; timeRemaining : timeRemaining &#125;);&#125;; ava单元测试如何debug？ 升级IntelliJ IDEA到新版本后，在package.json下添加的script里，添加字符串”$NODE_DEBUG_OPTION”，如下所示： babel的一些概念理解：babel-register？babel-standalone@6？plugin与preset的区别？ babel的编译过程： parser：通过 babylon 解析成 AST transform[s]：All the plugins/presets ，进一步的做语法等自定义的转译，仍然是 AST。 generator： 最后通过 babel-generator 生成 output string。 plugins与presets的区别：presets是一个plugin的集合，如babel-preset-env，根据当前的运行环境，确定需要的plugin组合 babel-register：require(‘babel-register’)后，所以require()其他模块时，就会进行文件编译，这个比较适合开发期间使用 babel-standalone@6：在browser上，对js代码实现在线转换，要完全支持React，需要配置对应的plugins和presets，如下所示：1234567891011&lt;html&gt;&lt;head&gt; &lt;script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\" data-plugins=\"transform-react-jsx\" data-presets=\"es2017,stage-3\"&gt; // react代码 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CommonJS与ES6模块的区别？ 详细请查看：ES6模块 和 CommonJS 的区别 本篇文章的code：diyreact 参考 Didact: a DIY guide to build your own React React Components, Elements, and Instances React Fiber Architecture requestIdleCallback-后台任务调度 babel的关键概念理解","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://handsomeliuyang.github.io/tags/前端/"}]},{"title":"MPVue源码分析","slug":"MPVue源码分析","date":"2018-06-07T06:34:35.000Z","updated":"2018-06-12T12:51:07.000Z","comments":true,"path":"2018/06/07/MPVue源码分析/","link":"","permalink":"https://handsomeliuyang.github.io/2018/06/07/MPVue源码分析/","excerpt":"","text":"Demo使用Vue实现一个消息逆转的demo：1234&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"reverseMessage\"&gt;逆转消息&lt;/button&gt;&lt;/div&gt; 1234567891011var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js!' &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split('').reverse().join('') &#125; &#125;&#125;) You can try it on CodePen. 同样的效果，使用小程序实现的代码为： 小程序的整体结构如下所示： : App相关的代码： 123456789101112131415// app.js文件App(&#123; onLaunch: function () &#123; console.log(\"App onLaunch...\"); &#125;, onShow: function()&#123; console.log(\"App onShow...\"); &#125;, onHide: function()&#123; console.log(\"App onHide...\"); &#125;, onError: function()&#123; console.log(\"App onError...\"); &#125;&#125;) 123456789101112// app.json&#123; \"pages\":[ \"pages/index/index\" ], \"window\":&#123; \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"WeChat\", \"navigationBarTextStyle\":\"black\" &#125;&#125; 12345678910// app.wxss.container &#123; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box;&#125; Page相关的代码： 1234567&lt;!--index.wxml--&gt;&lt;view class=\"container\"&gt; &lt;view class=\"usermotto\"&gt; &lt;text class=\"user-motto\"&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt; &lt;button bindtap=\"reverseMessage\"&gt;逆转消息&lt;/button&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718//index.jsPage(&#123; data: &#123; message: 'Hello Wechat!' &#125;, //生命周期函数 onLoad: function()&#123; console.log(\"Page onLoad...\"); &#125;, onReady: function()&#123; console.log(\"Page onReady...\"); &#125;, //事件处理函数 reverseMessage: function()&#123; // this.data.message = this.data.message.split('').reverse().join('') this.setData(&#123; message: this.data.message.split('').reverse().join('') &#125;) &#125;&#125;) 1234/**index.wxss**/.usermotto &#123; margin-top: 100px;&#125; 小程序简介Vue与小程序都可以看成javascript的高级抽象，类似于java里的各种框架，想让基于Vue开发的代码运行在小程序里，就把Vue的低层映射到小程序的Api，而不是Web端的Dom。 先来分析小程序的框架体系： 目录结构：包括App相关的三个文件，每个Page包括三个文件 代码结构： xxx.wxml布局文件，小程序特定的基础组件，如view，button, text xxx.js逻辑文件，类似于Vue对象的Page对象与App对象 xxx.wxss样式文件，与css一致，但支持样式属性列表不一样 类MVVM的响应式框架：V(wxml)，ViewModel(Page.data，Page.func) Page.data与wxml对应，通过setData()修改data数据，并自动更新View Vue的实现原理Vue运行期间，分为三个阶段： 初始化，生成Vue对象，让其具备如下属性与方法，如下所示： vm.$mount()后，建立整个响应式框架，并首次渲染Dom 事件响应，即用户交互 整个响应式框架如下图所示： MPVue的实现通过上面的小程序框架与Vue的实现原理介绍，基于Vue写的代码，要在小程序上运行，需要做如下工作： 编译期间生成小程序目录结构与代码结构 生成app相关的三个文件：app.js, app.json, app.wxss 生成Page相关的三个文件：xxx.js, xxx.wxml, xxx.wxss xxx.js的转换成本最低，基本不用变化，因为都是基于javascript语言写的 xxx.wxml：把Vue的template转换为小程序的基础组件，同时对组件的属性进行映射处理，成本较高 xxx.wxss：把Vue里的样式，直接转换过来就行，成本较低 对Vue运行时做修改，如下图所示： 部分核心代码： 初始化流程： 更新流程： MPVue源码介绍直接对着代码来分享 参考 小程序框架 read-vue-source-code Vue.js","categories":[{"name":"前端","slug":"前端","permalink":"https://handsomeliuyang.github.io/categories/前端/"}],"tags":[]},{"title":"react-native-wechatmini","slug":"react-native-wechatmini","date":"2018-04-02T11:17:05.000Z","updated":"2018-04-19T06:01:20.000Z","comments":true,"path":"2018/04/02/react-native-wechatmini/","link":"","permalink":"https://handsomeliuyang.github.io/2018/04/02/react-native-wechatmini/","excerpt":"","text":"// 实现思路 React包括两层编程模型：数据模型、UI界面。 React的核心点： VirsualDom 组件化 参考 微信小程序模块化","categories":[{"name":"前端","slug":"前端","permalink":"https://handsomeliuyang.github.io/categories/前端/"}],"tags":[]},{"title":"Gatsby搭建博客之旅","slug":"Gatsby搭建博客之旅","date":"2018-03-19T09:25:39.000Z","updated":"2018-03-26T12:41:33.000Z","comments":true,"path":"2018/03/19/Gatsby搭建博客之旅/","link":"","permalink":"https://handsomeliuyang.github.io/2018/03/19/Gatsby搭建博客之旅/","excerpt":"","text":"Gatsby简介 Blazing-fast static site generator for React （React的快速静态网站生成器） 几大特点： 1.Modern web tech without the headache（不再为web技术落后而头痛） Enjoy the power of the latest web technologies – React.js , Webpack , modern JavaScript and CSS and more — all setup and waiting for you to start building. (受最新Web前端技术的强大功能–React.js，Webpack，现代JavaScript和CSS等等，所有这一切都将启动并等待您的开始。) 2.Bring your own data (使用你自定义的数据) Gatsby’s rich data plugin ecosystem lets you build sites with the data you want — from one or many sources: Pull data from headless CMSs, SaaS services, APIs, databases, your file system &amp; more directly into your pages using GraphQL .(Gatsby丰富的数据插件生态系统允许您使用您想要的数据构建网站 - 来自一个或多个来源：使用GraphQL将数据从无头CMS，SaaS服务，API，数据库，文件系统等更直接地导入您的页面) 3.Scale to the entire internet (轻松发布到互联网) Gatsby.js is Internet Scale. Forget complicated deploys with databases and servers and their expensive, time-consuming setup costs, maintenance, and scaling fears. Gatsby.js builds your site as “static” files which can be deployed easily on dozens of services.（Gatsby.js是互联网化的。 你可以不用理会数据库和服务器的复杂部署，以及昂贵，耗时的设置成本，维护和缩放恐惧。 Gatsby.js将您的网站构建为“静态”文件，可以轻松部署在数十种服务上） 4.Future-proof your website (使您的网站面向未来) Don’t build a website with last decade’s tech. The future of the web is mobile, JavaScript and APIs—the JAMstack. Every website is a web app and every web app is a website. Gatsby.js is the universal JavaScript framework you’ve been waiting for.(不要用过去十年的技术建立一个网站。 网络的未来是移动的，JavaScript和API - JAMstack。 每个网站是一个Web应用程序，每个Web应用程序是一个网站。 Gatsby.js是你一直在等待的通用JavaScript框架。) 5.Static Progressive Web Apps (静态PWA) Gatsby.js is a static PWA (Progressive Web App) generator. You get code and data splitting out-of-the-box. Gatsby loads only the critical HTML, CSS, data, and JavaScript so your site loads as fast as possible. Once loaded, Gatsby prefetches resources for other pages so clicking around the site feels incredibly fast.(Gatsby.js是一个静态PWA（Progressive Web App）生成器。 您可以将代码和数据分开。 Gatsby只加载关键的HTML，CSS，数据和JavaScript，以便您的网站加载尽可能快。 一旦加载，Gatsby预取其他网页的资源，所以点击网站感觉非常快。) 6.Speed past the competition (超越竞争) Gatsby.js builds the fastest possible website. Instead of waiting to generate pages when requested, pre-build pages and lift them into a global cloud of servers — ready to be delivered instantly to your users wherever they are.(Gatsby.js建立最快的网站。 不需要等待请求时生成页面，而是预先生成页面，并将其提升到全球服务器云端 - 随时随地传送给用户，无论他们身在何处。) 工作原理： HelloWord按官网教程很容易创建一个简单的HelloWord。详见 常用命令： gatsby new xxx // 创建一个新的项目 gatsby develop // 构建开发站点 gatsby serve // 测试发布构建 gatsby build // 发布构建 效果如下： 技术点React，Webpack，ES6这三种技术就不重点介绍了 SASS Sass 是对 CSS 的扩展，让 CSS 语言更强大、优雅。 它允许你使用变量、嵌套规则、 mixins、导入等众多功能， 并且完全兼容 CSS 语法。 Sass 有助于保持大型样式表结构良好， 同时也让你能够快速开始小型项目， 特别是在搭配 Compass 样式库一同使用时。 更多请参考 GraphQL GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.(GraphQL是在API能提供的数据范围内，提供查询能力的语言。GraphQL在您的API中提供了对数据的完整和可理解的描述，使客户能够准确地询问他们需要什么，并且更容易随时间发展API，并支持强大的开发人员工具。) 更多请参考 Rest请求过程： GraphQL请求过程： GraphQL的特点： 入口统一，合并请求：不管请求什么资源，url都是一样的。这精简了不同场景下形态各异的API数量。 自定义返回值：在REST中，资源的返回结构与返回数量是由服务端决定；在GraphQL，服务端只负责定义哪些资源是可用的，由客户端自己决定需要得到什么资源，避免让API消费者取到对它来说并没有用的冗余数据。 数据的关联性：在query里，通过id，可以把多个数据源或Api直接关联起来 方便的接口调试工具：GraphiQL工具，文档与调试统一，GraphiQL / live demo 注意：GraphQL是一种标准，但其具体的实现里，有些标准的特性并没有被实现。如下所描述的一样： 从官方的定义来说，GraphQL 是一种针对 API 的查询语言；在我看来，GraphQL 是一种标准，而与标准相对的便是实现。就像 EcmaScript 与 JavaScript 的关系，从一开始你就需要有这样一种认知：GraphQL 只定义了这种查询语言语法如何、具体的语句如何执行等。但是，你在真正使用某种 GraphQL 的服务端实现时，是有可能发现 GraphQL 标准中所描述的特性尚未被实现；或者这种 GraphQL 的实现扩展了 GraphQL 标准所定义的内容。 举例来说，就像 ES 2017 标准正式纳入了 async/await，而从实现的角度上说，IE 没有实现这一标准，而 Edge 16 和 Chrome 62 则实现了这一标准（数据来源于 caniuse）说回 GraphQL 标准，与之相对的有相当多的服务器端实现。他们的大多遵循 GraphQL 标准来实现，但也可能稍有差别，这一切需要你自己去探索。 PWA Progressive Web App, 简称 PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。 PWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。 更多请参考 Gatsby搭建博客注意：node需要安装6.x版本，Markdown插件gatsby-transformer-remark，在node 8.x与9.x会运行失败 node下载 一个博客主要包括下面几部分： 主页，包括作者介绍，文章列表 Post页面(文章正文页) 归档页，Categories页，Tags页，关于页 工程目录 第三方库 lost：Lost Grid是一个强大的网格系统，可以方便实现表格拆分 moment：解析，验证，操作和显示日期 react-media：适配不同屏幕 主页 Layout在我们这个demo里，首页与Post没有相同的部分，如footer，header，所以Layout里，非常的简单：123456789101112131415161718import React from 'react'import Helmet from 'react-helmet'import \"./style.scss\";class Layout extends React.Component &#123; render()&#123; const &#123;children&#125; = this.props; return ( &lt;div className=\"layout\"&gt; &lt;Helmet defaultTitle=\"Blog by LiuYang\"/&gt; &#123;children()&#125; &lt;/div&gt; ); &#125;&#125;export default Layout; 如果有共同的footer与header，则应该在layout里实现 首页整体布局包括左边Sidebar和右边的文章列表，按组件思维考虑，我们应该创建三个组件或者二个组件： 下面是创建二个组件的首页布局代码：12345678910111213141516171819202122232425262728class IndexRoute extends React.Component &#123; render()&#123; const &#123;title, subtitle&#125; = this.props.data.site.siteMetadata; const &#123;edges:posts&#125; = this.props.data.allMarkdownRemark; return ( &lt;div&gt; &lt;Helmet&gt; &lt;title&gt;&#123;title&#125;&lt;/title&gt; &lt;meta name=\"description\" content=&#123;subtitle&#125;/&gt; &lt;/Helmet&gt; &lt;Sidebar &#123;...this.props&#125;/&gt; &lt;div className=\"content\"&gt; &lt;div className=\"content__inner\"&gt; &#123; posts .filter((&#123;node:post&#125;) =&gt; post.frontmatter.title.length &gt; 0) .map((&#123;node:post&#125;)=&gt;&#123; return ( &lt;Post data=&#123;post&#125; key=&#123;post.fields.slug&#125;/&gt; ); &#125;) &#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 适应不同尺寸的屏幕常见屏幕大小有： lg：宽度大于1100px的屏幕 md：宽度在[960px–1100px]之间的屏幕 sm：宽度在[685px–960px]之间的屏幕 xs：宽度在[0px–685px]之间的屏幕 在不同屏幕下，首页布局也要有相应的变化，利用css的@media实现不同屏幕的适配：CSS @media Rule12345678910111213141516171819202122232425262728293031323334// _breakpoints.scss@mixin breakpoint-sm &#123; @media screen and (min-width: 685) &#123; @content &#125;&#125;@mixin breakpoint-md &#123; @media screen and (min-width: 960) &#123; @content &#125;&#125;// index.js的scss.content &#123; &amp;__inner &#123; padding:25px 20px; &#125;&#125;@include breakpoint-sm &#123; .content &#123; lost-column: 7/12; &amp;__inner &#123; padding: 30px 20px; &#125; &#125;&#125;@include breakpoint-md &#123; .content &#123; lost-column: 2/3; &amp;__inner &#123; padding: 40px 35px; &#125; &#125;&#125; 注意上面的样式是叠加的，下面的会覆写掉面上样式。 空格实现在html页面里，想实现空隔效果，可以有下面几种方案： 通过空格的特殊字符实现 全角下的空格 通过css样式实现，占位div，再设置其margin值 博客相关的gatsby插件 gatsby-source-filesystem：读取本地文件 gatsby-transformer-remark：使用Remark解析Markdown文件 gatsby-remark-images：用于解析图片 gatsby-plugin-postcss-sass：支持sass 默认通过GraphQL无法查询到文件相关的数据，当安装了gatsby-source-filesystem插件后，可以查询到File相关的数据： 安装了gatsby-transformer-remark插件后，就可以查询Markdown相关的数据了： markdown的node结点的parent是file结点，即markdown是基于上一次插件的结果产生的，减少重复制造轮子 Post页面 页面的思路与主页的思路一样，使用组件化的思路设计，唯一的不同点是代码高亮显示 主页是一个固定页，但Post页面有很多，如果批量生成？使用gatsby的扩展点及Api来实现，整体流程如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445exports.createPages = (&#123;graphql, boundActionCreators&#125;)=&gt;&#123; const &#123;createPage&#125; = boundActionCreators; return new Promise((resolve, reject)=&gt;&#123; const postTemplate = path.resolve('./src/templates/post-template.js'); // 查询所有的markdown，并创建相应的页面 resolve( graphql(`&#123; allMarkdownRemark( limit: 1000 ) &#123; edges &#123; node &#123; fields &#123; slug &#125; frontmatter &#123; category &#125; &#125; &#125; &#125; &#125;`).then((result)=&gt;&#123; if (result.errors) &#123; console.log(result.errors); reject(result.errors) &#125; // 创建对应的markdown页面 result.data.allMarkdownRemark.edges.forEach((edge) =&gt; &#123; createPage(&#123; path: edge.node.fields.slug, // required component: slash(postTemplate), context: &#123; slug: edge.node.fields.slug, &#125;, &#125;); &#125;); resolve(); &#125;) ) &#125;);&#125;; Gatsby与Hexo的对比调研Gatsby的初衷是想把博客实现由Hexo替换为Gatsby，Hexo与Gatsby都是静态网站生成器，主要差别是使用的技术不一样，Gatsby使用的都是最新技术，但最后还是继续使用了Hexo，主要原因是：Hexo提供了很多的Themes，能快速复用这些Themes。 此Demo的地址：Gatsby-demo 参考 中文gatsby介绍 gatsbyjs 约定优于配置 阻碍你使用 GraphQL 的十个问题 GraphQL is the better REST 对比GraphQL与REST——两种HTTP API的差异 GraphQL vs RESTful API 的一些想法 gatsby-starter-lumen","categories":[{"name":"前端","slug":"前端","permalink":"https://handsomeliuyang.github.io/categories/前端/"}],"tags":[]},{"title":"抽屉效果实现三端化（android，ios，web）的历程","slug":"抽屉效果实现三端化的历程","date":"2018-03-03T16:00:00.000Z","updated":"2018-03-26T12:41:45.000Z","comments":true,"path":"2018/03/04/抽屉效果实现三端化的历程/","link":"","permalink":"https://handsomeliuyang.github.io/2018/03/04/抽屉效果实现三端化的历程/","excerpt":"","text":"ReactNative运行通过Native Code的运行命令是： 1react-native run-android 具体过程： 启动js server: 用于生成本地打包服务Metro，地址：http://localhost:8081 编译打包，并安装：cd android &amp;&amp; ./gradlew installDebug 手机通过http://localhost:8081访问js server：adb reverse tcp:8081 tcp:8081 启动App：adb shell am start -n 包名/activity App运行时，默认请求bundle的地址为：http://ip:8081/xxx 问题：当电脑切换wifi后，模拟器无法连接js server？原因：电脑的ip地址变了，但App请求bundle地址没有变彻底解决方案：在App里，进入Developer Menu，修改bundle请求地址为：http://localhost:8081 android模拟器快捷键 Developer Menu： ⌘M Reload：two R 注意：使用x86的模拟器，此模拟器的运行速度与真机一致 react-native-web部署通过ReactNative的Metro编译出的bundle.js文件，只能在对应的App里运行，无法直接在浏览器里运行。 在不考虑自定义View和Module的情况，要想生成的bundle.js可以直接在浏览器里运行，理论上只需要两步： 实现一套在浏览器里支持运行的react-native-web库 不通过Metro打包，通过webpack打包，把react-native-web库替换react-native库，同时打包在一起 react-native-web已经有实现版本了，详情请查看react-native-web 相应的webpack的配置过程，请参考：react-native-web-webpack 配置完后，不用对ReactNative代码做任何改动，就能直接在浏览器上支持运行，主要是使用了webpack的alias功能（整体替换react-native库）： 12345resolve: &#123; alias: &#123; 'react-native': 'react-native-web', &#125;&#125; 三端实现：抽屉效果调研方案1：仿照DrawerLayoutAndroid的Api，实现DrawerLayoutIOS和DrawerLayoutWeb两套View 方案2：react-navigation库也实现了DrawerLayoutWeb，在webpack如下配置，就可以使用了： 12345resolve: &#123; alias: &#123; &apos;react-navigation&apos;: &apos;react-navigation/lib/react-navigation.js&apos;, &#125;&#125; 注意：不是所有的react-navigation版本都能测试成功，1.0.0-beta.10测试通过，但beta.50测试失败更详细的信息：Navigating in all platforms 方案3：使用基本组件（View，Animated，TouchableWithoutFeedback等），实现DrawerLayout，即可满足三端运行（react-native-drawer-layout） 此方案有一定的适配的问题，可能在android4.x系统里，运行会有一些问题 抽屉效果实现（方案3）实现弹窗效果 实现分析： 整体有三层View，最底层是首页，中间是遮罩层，最上层是抽屉 正常Flexbox布局相当于Android里的LinearLayout布局，但通过position=absolute，与zindex可实现叠加效果，更多请参考CSS position Property 123456789101112131415161718192021222324252627282930&lt;View style=&#123;&#123; flex: 1, backgroundColor: &apos;transparent&apos;&#125;&#125;&gt; &lt;View style=&#123;&#123; flex: 1, zIndex: 0, &#125;&#125;&gt; &#123;this.props.children&#125; // 子布局 &lt;/View&gt; &lt;View style=&#123;&#123; backgroundColor: &apos;#000000&apos;, position: &apos;absolute&apos;, top: 0, left: 0, bottom: 0, right: 0, zIndex: 1000, &#125;&#125;&gt; &lt;/View&gt; &lt;View style=&#123;&#123; position: &apos;absolute&apos;, top: 0, bottom: 0, zIndex: 1001 &#125;&#125;&gt; &#123;this.props.renderNavigationView()&#125; // 抽屉布局 &lt;/View&gt;&lt;/View&gt; 实现抽屉展开与收起动画 两个动画： 遮罩层渐隐和渐现动画 抽屉水平移动动画 2维动画实现的思路比较简单，以遮罩层的渐隐动画为例： 假设当前的透明度为变量x，例用Animated.View的opacity样式 1234567891011121314.......... &lt;Animated.View style=&#123;&#123; backgroundColor: &apos;#000000&apos;, position: &apos;absolute&apos;, top: 0, left: 0, bottom: 0, right: 0, zIndex: 1000, opacity: x // 设置透明度 &#125;&#125;&gt; &lt;/Animated.View&gt; .......... 定时修改变量x，并重新渲染，动画就行成了 真正的实现： 通过变量设置透明度与水平移动理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849render()&#123; const &#123;drawerWidth, drawerBackgroundColor&#125; = this.props; const &#123;openValue, drawerShown&#125; = this.state; const dynamicDrawerStyles = &#123; backgroundColor: drawerBackgroundColor, width: drawerWidth, left: 0, &#125;; let drawerTranslateX = openValue.interpolate(&#123; inputRange: [0, 1], outputRange: [-drawerWidth, 0], &#125;); const animatedDrawerStyles = &#123; transform: [&#123; translateX: drawerTranslateX&#125;], &#125;; const overlayOpacity = openValue.interpolate(&#123; inputRange: [0, 1], outputRange: [0, 0.7], &#125;); const animatedOverlayStyles = &#123;opacity: overlayOpacity&#125;; const pointerEvents = drawerShown ? &quot;auto&quot; : &quot;none&quot;; return ( &lt;View style=&#123;&#123; flex: 1, backgroundColor: &apos;transparent&apos;&#125;&#125;&gt; &lt;Animated.View style=&#123;styles.main&#125;&gt; &#123;this.props.children&#125; &lt;/Animated.View&gt; &lt;TouchableWithoutFeedback pointerEvents=&#123;pointerEvents&#125; onPress=&#123;this._onOverlayClick&#125;&gt; &lt;Animated.View pointerEvents=&#123;pointerEvents&#125; style=&#123;[styles.overlay, animatedOverlayStyles]&#125;&gt; &lt;/Animated.View&gt; &lt;/TouchableWithoutFeedback&gt; &lt;Animated.View style=&#123;[styles.drawer, dynamicDrawerStyles, animatedDrawerStyles]&#125;&gt; &#123;this.props.renderNavigationView()&#125; &lt;/Animated.View&gt; &lt;/View&gt; );&#125; 定时修改变量 123456Animated.spring(this.state.openValue, &#123; toValue: 1, bounciness: 0, // restSpeedThreshold: 0.1, useNativeDriver: true &#125;).start(); 重点知识点： css3也有一个transform属性，但这个是ReactNative的transform属性，有区别，其分别对应的文档： ReactNative的transform css3的transform translateX属性的范围不是0–1，而实际抽屉的宽度 渐隐取值范围：[0–0.7]，水平移动画的取值范围：[0–抽屉的宽广]，变量openValue的取值范围：[0–1]。Animated.Value()的interpolate()方法进行转换，使其在同一个维度 特别注意：使用Animated.Value变量时，只能在Animated.View里使用，不能直接在View里使用，会出现各种想像不到的问题 遮罩层的事件处理这个比较简单，通过TouchableWithoutFeedback就可以实现 注意：overlay设置为全透明后，还是一样可以拦截或透传事件，通过View的pointerEvents属性配制事件传递 触发抽屉显示动画下面是真正的使用DrawerLayout的代码： 123456789101112render()&#123; const navigationView = React.createElement(NavigationScreen); // 抽屉View return ( &lt;DrawerLayout drawerWidth=&#123;300&#125; drawerBackgroundColor=&apos;#DAE8FC&apos; renderNavigationView=&#123;()=&gt;navigationView&#125; ref=&#123;(drawer)=&gt;&#123;this.drawerLayout = drawer;&#125;&#125;&gt; &lt;HomeScreen navigate=&#123;this.navigate&#125;/&gt; // 首页 &lt;/DrawerLayout&gt; );&#125; 真正触发抽屉显示动画的是HomeScreen(首页)，并不是DrawerLayout自已，所以需要使用React的ref属性，把DrawLayout的引用传递给其他View，才能调用其对外提供的Api。 学习到的技术点（记住）端口映射(USB连接) 在手机设备里通过http://localhost:port/访问pc上的服务时，使用如下命令： 12adb reverse (remote) (local)例子：adb -s 设备 reverse tcp:8081 tcp:8081 在pc上通过http://localhost:port/，访问手机设备上的服务时，使用如下命令： 12adb forward (local) (remote)例子：adb forward tcp:8081 tcp:8081 函数里的this的理解 this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。更多信息 通过.bind()可以修改this的指向 箭头函数的this，是由定义时的上下文决定，而不是由运行时决定。 在ES6里，定义类时，其函数的写法有下面两种： 1234567891011121314class Person &#123; constructor()&#123; this.name = &quot;Li&quot;; this.age = &quot;18&quot;; &#125; getName()&#123; console.log(&quot;Person.name=&quot; + this.name); &#125; getAge = ()=&gt;&#123; console.log(&quot;Person.age=&quot; + this.age); &#125;&#125; getName()方法，在下面的场景下会执行有问题： 123const person = new Person(xxx);const tempGetName = person.getName;tempGetName(); // this为window 要解决这个问题，需要在构造函数里添加：this.getName = this.getName.bind(this) getName()与getAge()方法的其他不同点： getName()定义在原型上，getAge()定义在对象上，当类的对象很多时，比较占内存 123456789101112131415// getAge()方法相当于在构造函数里创建constructor(props)&#123; super(props); this.name = &quot;Li&quot;; this.age = &quot;18&quot;; this.getAge = ()=&gt;&#123; console.log(&quot;Person.age=&quot; + this.age); &#125;&#125;// getName()相当于在原型上定义Person.prototype.getName = function()&#123; console.log(&quot;Person.age=&quot; + this.age);&#125; 箭头函数的继承的三种情况： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 继承1class Student extends Person&#123; getAge = ()=&gt;&#123; super.getAge(); console.log(&quot;Student.age&quot;); &#125;&#125;new Student().getAge();// Uncaught TypeError: (intermediate value).getAge is not a function// 继承2class Student extends Person&#123; getAge()&#123; super.getAge(); console.log(&quot;Student.age&quot;); &#125;&#125;new Student().getAge();// Person.age=18// 继承3class Student extends Person&#123; &#125;new Student().getAge();// Person.age=18// 继承4class Student extends Person&#123; getName()&#123; super.getName(); console.log(&quot;Student.name&quot;); &#125;&#125;new Student().getName();// Person.name=Li// Student.name// 继承5class Student extends Person&#123; getName=()=&gt;&#123; super.getName(); console.log(&quot;Student.name&quot;); &#125;&#125;new Student().getName();// Person.name=Li// Student.name 结论就是：箭头函数可以继承，但无法被重写 flexbox布局理解 Flex布局类似于Android里的LinearLayout布局，flexDirection，justifyContent，alignItems，alignSelf width，height的值尖似于dip，会依据手机的屏幕进行转换，PixelRatio更多信息 Flex的布局，默认是一层布局，通过position=absolute，与zindex可实现Android里的RelativeLayout效果。CSS position Property webpack的resolve.alias可以给import或require设置别名，利用此特性，可以把引入库修改掉，但同时又不用修改源码，更多信息 React的组件之间的交互方式默认情况下，props是父组件与子组件交互的唯一方式，父组件要修改子组件，通过新的props去重新渲染子组件。这种方案可以起到很好的解耦，但在少数情况下，无法满足需求，如抽屉的展开与收起动画。 这种情况下，可以使用Refs，比较适合使用refs的场景： 处理focus、文本选择或者媒体播放 触发强制动画 集成第三方DOM库 更多请参考 参考 BABEL在线转换工具","categories":[{"name":"前端","slug":"前端","permalink":"https://handsomeliuyang.github.io/categories/前端/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://handsomeliuyang.github.io/tags/ReactNative/"}]},{"title":"微信聊天数据定时清理","slug":"微信聊天数据定时清理","date":"2017-12-12T02:42:49.000Z","updated":"2017-12-14T06:48:24.000Z","comments":true,"path":"2017/12/12/微信聊天数据定时清理/","link":"","permalink":"https://handsomeliuyang.github.io/2017/12/12/微信聊天数据定时清理/","excerpt":"","text":"技术方案选择Android测试支持库有： Junit3, Junit4：用于方法级别的单元测试，不通过手机运行，在测试一些正则表达式时，非常方便 AndroidJUnitRunner：在手机上运行Junit测试，如一些需要获取Context的方法 Espresso：UI 测试框架；适合应用中的功能性 UI 测试。 UI Automator：UI 测试框架；适合跨系统和已安装应用的跨应用功能性 UI 测试 无障碍Api：可用于模拟用户点击，适合跨系统和已安装应用的跨应用功能性UI测试 选择结果：无障碍Api，因为UI Automator只能通过adb shell运行。 注意：Root后的手机，应该可以在App内直接执行UI Automator — 没有经过测试 实现步骤定时机制定时机制很容易，使用AlarmManager就行，如下所示：123456789101112131415161718//点击，设置重复闹钟。private void setRepeatingAlarm()&#123; Intent intent = new Intent(this, ClearWeixinActivity.class); intent.putExtra(\"msg\", \"重复的事情多次提醒！！！\"); intent.putExtra(\"type\", \"repeat\"); PendingIntent pendingIntent = PendingIntent.getActivity(this, 101, intent, 0); //假设当前时间15s之后，就开始第一次触发；然后每隔20s再次触发。 Calendar c = Calendar.getInstance(); c.set(Calendar.SECOND, c.get(Calendar.SECOND) + 60*60*1); AlarmManager alarmManager = (AlarmManager)getSystemService(ALARM_SERVICE); alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, c.getTimeInMillis(), 1*60*60*1000, // 1个小时 pendingIntent);&#125; 注意： 当进程被杀后，闹钟无法调起应用，需要开启自启动服务 自动开启无障碍模式由于无障碍模式的开启后，当应用程序进程被杀后，无障碍模式会被关掉，所以需要自动打开无障碍模式。 通过命令打开障碍模式的命令如下： 123456// 打开无障碍模式adb shell settings put secure enabled_accessibility_services com.ly.robottool/com.ly.robottool.weixin.ClearWeixinServiceadb shell settings put secure accessibility_enabled 1// 查看无障碍的配置情况adb shell content query --uri content://settings/secure App里，通过获取Root权限后，可执行以上命令，如下所示： 1234567891011121314151617try &#123; Process p = Runtime.getRuntime().exec(\"su\"); DataOutputStream dos = new DataOutputStream(p.getOutputStream()); dos.writeBytes(\"settings put secure enabled_accessibility_services com.ly.robottool/com.ly.robottool.weixin.ClearWeixinService\\n\"); dos.writeBytes(\"settings put secure accessibility_enabled 1\\n\"); dos.writeBytes(\"mkdir /sdcard/333\\n\"); dos.writeBytes(\"exit\\n\"); dos.flush(); dos.close(); p.waitFor(); mHander.sendEmptyMessageDelayed(MESSAGE_ACCESSIBILITY_SUCCESS, 1000*1);&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; 注意： 上面的代码，需要在子线程里执行 无障碍服务无障碍的整体机制 无障碍Api更加详细的文档，请查看Android开发无障碍指南 总结一些关键点： 默认情况下，只能看到TextView及其ParentView，基他ImageView等等都看不到，但通过设置flags |= FLAG_INCLUDE_NOT_IMPORTANT_VIEWS后，可以看到其他没有包含TextView的View 只能看到标准View，即自定View的父类，无法看到自定View的类名 只能获取View的Parent，children，Text，ClassName，屏幕坐标，大小，viewId，一些状态（checkable，checked，focusable，focused，selected，clickable，longClickable） 注意：微信由于使用了资源id混淆技术，不同版本的微信apk，其viewid会变化 UIAutomatorViewer查看IDuiautomatorviewer工具所在目录：Android SDK/tools/bin/uiautomatorviewer 与dumpsys比较： 结论：uiautomator，uiautomatorviewer，无障碍Api都只能看到TextView及其ParentView，但dumpsys可以看到全部View 微信自动清理聊天记录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public void onAccessibilityEvent(AccessibilityEvent event) &#123; if (event == null) &#123; return; &#125; if (!WECHAT_PACKAGENAME.equals(event.getPackageName())) &#123; return; &#125; String beginUUID = SharedPreferenceUtils.getBeginUUID(this); String endUUID = SharedPreferenceUtils.getEndUUID(this); if(beginUUID == null) &#123; return ; &#125; if(!beginUUID.equals(endUUID)) &#123; SharedPreferenceUtils.updateEndUUID(this, beginUUID); hasClickMe = false; hasClickSetting = false; hasClickChat = false; hasEnterClearDialog = false; hasClickClear = false; &#125; log(\"0000:\" + event); if(!hasClickMe) &#123; enterPerson(event); return ; &#125; if(!hasClickSetting)&#123; enterSetting(event); return ; &#125; if(!hasClickChat)&#123; enterChat(event); return ; &#125; if(!hasEnterClearDialog)&#123; enterClearDialog(event); return ; &#125; if(!hasClickClear)&#123; clickClear(event); return ; &#125;&#125;private void enterPerson(AccessibilityEvent event)&#123; if(!\"com.tencent.mm.ui.LauncherUI\".equals(event.getClassName()))&#123; return ; &#125; if(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED == event.getEventType())&#123; // 查找当前窗口中包含“安装”文字的按钮 List&lt;AccessibilityNodeInfo&gt; nodes = getRootInActiveWindow().findAccessibilityNodeInfosByViewId(\"com.tencent.mm:id/c3f\"); AccessibilityNodeInfo myNode = null; for(AccessibilityNodeInfo node : nodes)&#123; if(\"我\".equals(node.getText())) &#123; myNode = node; &#125; &#125; if(myNode == null) &#123; return ; &#125; myNode.getParent().performAction(AccessibilityNodeInfo.ACTION_CLICK); hasClickMe = true; &#125;&#125; 参考 Android开发无障碍指南","categories":[{"name":"Android","slug":"Android","permalink":"https://handsomeliuyang.github.io/categories/Android/"}],"tags":[{"name":"自动化测试","slug":"自动化测试","permalink":"https://handsomeliuyang.github.io/tags/自动化测试/"}]},{"title":"异或总结","slug":"异或总结","date":"2017-08-18T07:28:51.000Z","updated":"2017-09-19T09:48:28.000Z","comments":true,"path":"2017/08/18/异或总结/","link":"","permalink":"https://handsomeliuyang.github.io/2017/08/18/异或总结/","excerpt":"","text":"异或（exclusive or）的定义符号： XOR 或 EOR 或 ⊕（编程语言中常用^） 定义：逻辑运算里，仅当两个运算元中恰有一个的值为真，而另外一个的值为非真时，其值为真 1 ⊕ 1 = 00 ⊕ 0 = 01 ⊕ 0 = 10 ⊕ 1 = 1 异或的特性 恒等律：X ⊕ 0 = X （X为任意整数）归零律：X ⊕ X = 0 （X为任意整数）交换律：A ⊕ B = B ⊕ A结合律：(A ⊕ B) ⊕ C = A ⊕ (B ⊕ C) 通过异或解决具体问题判断两个数是否相等技算机底层判断整数是否相等的方案：通过先将相应的位进行异或操作，然后将所有异或操作的结果进行或操作。因为执行异或操作没有进位，因此，这种方法比用ALU将两个数相减，然后再判断输出是否为0要快得多。 Linux中最初的ipv6_addr_equal()函数的实现：123456789101112131415static inline int ipv6_addr_equal(const struct in6_addr *a1, const struct in6_addr *a2)&#123; return (a1-&gt;s6_addr32[0] == a2-&gt;s6_addr32[0] &amp;&amp; a1-&gt;s6_addr32[1] == a2-&gt;s6_addr32[1] &amp;&amp; a1-&gt;s6_addr32[2] == a2-&gt;s6_addr32[2] &amp;&amp; a1-&gt;s6_addr32[3] == a2-&gt;s6_addr32[3]);&#125;static inline int ipv6_addr_equal(const struct in6_addr *a1, const struct in6_addr *a2)&#123; return (((a1-&gt;s6_addr32[0] ^ a2-&gt;s6_addr32[0]) | (a1-&gt;s6_addr32[1] ^ a2-&gt;s6_addr32[1]) | (a1-&gt;s6_addr32[2] ^ a2-&gt;s6_addr32[2]) | (a1-&gt;s6_addr32[3] ^ a2-&gt;s6_addr32[3])) == 0);&#125; 数据校验利用异或的特性：IF a ^ b = c THEN a ^ c = b, b ^ c = a RAID5，大概原理为：使用3块磁盘（A、B、C）组成RAID5阵列，当用户写数据时，将数据分成两部分，分别写到磁盘A和磁盘B，A ^ B的结果写到磁盘C；当读取A的数据时，通过B ^ C可以对A的数据做校验，当A盘出错时，通过B ^ C也可以恢复A盘的数据。 bit位的一些操作判断一个二进制数中1的数量是奇数还是偶数如100010111中1的数量是奇数还是偶数？ 解答：1^0^0^0^1^0^1^1^1 = 1 特定位进行翻转利用异或的特性：1^1=0，0^1=1。 如翻转100010111里的第5位？ 解答：100010111 ^ 000010000 = 100000111 不使用其他空间，交换两个值1234int a,b;a = a ^ b;b = a ^ b; // a^b^b=aa = a ^ b; // a^b^a=b 一个整型数组里除了1个数字之外，其他的数字都出现两次，请查找出其中从一组数据中找出只出现一次的数字比如，从[3, 2, 3, 2, 4, 5, 5, 6, 6]中找出只出现一次的数字：4 利用异或的三个定律：归零律，交换律，结合律。 1233 ^ 2 ^ 3 ^ 2 ^ 4 ^ 5 ^ 5 ^ 6 ^ 6= 3 ^ 3 ^ 2 ^ 2 ^ 5 ^ 5 ^ 6 ^ 6 ^ 4= 4 一个整型数组里除了2个数字之外，其他的数字都出现两次，请查找出其中从一组数据中找出只出现一次的数字比如，从[a, b, a, b, c, d, e, f, e, f]中找出只出现一次的数字：c, d 思路： 整体异或的结果为c与d的异或值：cXORd，因c != d，则 cXORd != 0； 利用cXORd的第一位值为1（比如从右向左第一位），来区分c与d，如下图所示： 从数组里，找到所有第二位都为1的数字，假设有：[ a, a, c, e, f, e, f]，再对这些数进行异或：a ^ a ^ c ^ e ^ f ^ e ^ f = c 再利用异或的特性：cXORd ^ c = d 代码1234567891011121314151617181920212223242526public static int getFirstOneBit(int a)&#123; return a | (~a + 1); // 由a | -a即可以获取&#125;public static void findTwo(int[] array)&#123; if(array == null || array.length == 0) &#123; return ; &#125; int cXORd = 0; for(int item : array)&#123; cXORd = cXORd ^ item; &#125; int firstOneBit = getFirstOneBit(cXORd); int c = 0; for(int item : array)&#123; if(getFirstOneBit(item) == firstOneBit)&#123; c = c ^ item; &#125; &#125; int d = cXORd ^ c; System.out.printf(\"findTwo num is %d, %d\\n\", c, d);&#125; 时间复杂度为O(n)，空间复杂度O(1) 一个整型数组里除了3个数字之外，其他的数字都出现两次，请查找出其中从一组数据中找出只出现一次的数字比如，从[a, b, a, b, c, d, e, f, f]中找出只出现一次的数字：c, d，e 思路： 整体异或的结果为c,d,e的异或值：cXORdXORe。同时(cXORdXORe ^ c) ^ (cXORdXORe ^ d) ^ (cXORdXORe ^ e) = 0 IF A ^ B ^ C = 0, 则可以得出如下结论： 把查找3个数字，转换为2个数字的问题 代码12345678910111213141516171819202122232425262728293031public static void findThree(int[] array)&#123; if(array == null || array.length == 0)&#123; return ; &#125; int cXORdXORe = 0; for(int item : array)&#123; cXORdXORe = cXORdXORe ^ item; &#125; int firstBit = 0; for(int item : array)&#123; firstBit = firstBit ^ getFirstOneBit(cXORdXORe ^ item); &#125; int c = 0; for(int item : array)&#123; if(getFirstOneBit(cXORdXORe ^ item) == firstBit)&#123; c = c ^ item; &#125; &#125; System.out.printf(\"findThree num is %d \", c); int[] findtwoArray = new int[array.length + 1]; for(int i=0; i&lt;array.length; i++)&#123; findtwoArray[i] = array[i]; &#125; findtwoArray[findtwoArray.length - 1] = c; findTwo(findtwoArray);&#125; 时间复杂度O(n)，空间复杂度O(1) 参考 感受异或的神奇","categories":[{"name":"算法","slug":"算法","permalink":"https://handsomeliuyang.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://handsomeliuyang.github.io/tags/算法/"}]},{"title":"Docker-Jenkins服务搭建","slug":"Docker-Jenkins服务搭建","date":"2017-07-14T05:28:44.000Z","updated":"2017-07-25T02:55:48.000Z","comments":true,"path":"2017/07/14/Docker-Jenkins服务搭建/","link":"","permalink":"https://handsomeliuyang.github.io/2017/07/14/Docker-Jenkins服务搭建/","excerpt":"","text":"Docker介绍Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker理解 Dockerfile面向开发，Docker 镜像成为交付标准，Docker 容器则涉及部署与运维 Docker类似于一个虚拟机，实现资源和系统环境的隔离 Docker镜像类似于Ghost系统，为了方便快速使用，已经完成了服务的所有配置。 DockerFile是一个脚本，用于生成Docker镜像的脚本 Docker镜像不仅可以从DockerFile生成，也可以从Docker容器生成，但最好是通过DockerFile来生成，方便后期维护。 我们创建新的镜像都是从系统镜像开始创建的，如centos:7，centos：6 通过Docker部署Jenkins的好处Docker解决现在的迁移服务(如Android的Jenkins)存在的问题： 服务器的系统版本不一致，容易出现新问题，如缺少一些库，或软件版本过底 Docker：容器里的操作系统版本与主机的系统版本没有关系，不受主机的系统版本影响 多个服务部署在同一台机器上，关联的软件出现相互影响 Docker：每个容器之间相互不影响，完全透明，类似虚拟机 需要写服务部署文档，软件版本之间的关系，但新系统有可能不支持这些老版本的软件 Docker：DockerFile就是整个部署文档，安装的软件与主机的系统没有关系 服务卸载的成本很高，很容易出现卸载不完全的问题 Docker：只需要删除容器，其安装的软件都可以清除 服务升级很不方便，需要一台新机器或搭建虚拟机来实现 Docker：容器升级操作系统版本非常简单，成本非常低，修改From的关联版本就行 本地文件管理比较乱，容易相互影响 Docker：容器之间的文件相互不影响 Docker入门介绍Docker安装在centos上安装Docker的注意点： 最低支持centos7.0系统才能安装docker centos6.5以上也可以安装，但安装方法与centos7.0以上的安装方法不一样 具体教程可以网上查找 常用命令DockerFile生成Docker镜像1234docker build -t 镜像名称 DockerFile所在的目录// 例子docker build -t btown-jenkins . 从Docker镜像创建Docker容器1234docker run [-d|-it] -p 主机端口:容器里的端口 -v 主机目录:容器里的目录 -v 主机目录:容器里的目录 镜像名称 bash// 例子docker run -it --name btown-jenkins -p 7000:8080 -v /data0/btown_jenkins_home/jobs:/var/lib/jenkins/jobs -v /data0/btown_jenkins_home/logs:/var/lib/jenkins/logs -v /data0/btown_jenkins_home/nodes:/var/lib/jenkins/nodes -v /data0/btown_jenkins_home/secrets:/var/lib/jenkins/secrets -v /data0/btown_jenkins_home/users:/var/lib/jenkins/users -v /data0/btown_jenkins_home/workspace:/var/lib/jenkins/workspace btown-jenkins bash -d：此容器在后台运行 -it：当前控制台与容器交互 –name：创建的容器的名称 -p：端口映射，把主机的端口映射到容器里的端口 -v：目录映射，把容器里的目录映射到主机里的目录 bash：进入容器后的命令，bash表示直接进入shell状态 数据备份默认情况下，容器运行期间产生的文件，都处于沙箱当中，当容器删除后，也会自动删除，这会造成一些问题： 服务生成的数据很不方便备份 容器挂了后，就无法恢复数据了 容器会变的非常的大 无法共享容器间的数据 Docker 容器文件系统 Dockerfile 中的每一条命令，都在 Docker 镜像中以一个独立镜像层的形式存在 Docker 镜像是由 Dockerfile 构建而成，但并不是每一层 Docker 镜像中都含有相应的文件系统文件 Docker 容器的文件系统中不仅包含 Docker 镜像，还包含初始层（Init Layer）与可读写层（Read-Write Layer）。 初始化层（Init Layer）：初始层中大多是初始化容器环境时，与容器相关的环境信息，如容器主机名，主机 host 信息以及域名服务文件等。 可读写层（Read-Write Layer）：这一层的作用非常大，Docker 的镜像层以及顶上的两层加起来，Docker 容器内的进程只对可读写层拥有写权限，其他层对进程而言都是只读的（Read-Only） Docker 容器有能力在可读写层看到VOLUME文件等内容，但那都仅仅是挂载点，真实内容位于宿主机上 Volume 命令为了能够保存（持久化）数据以及共享容器间的数据，Docker提出了Volume的概念。简单来说，Volume就是目录或者文件，它可以绕过默认的联合文件系统，而以正常的文件或者目录的形式存在于宿主机上。 有两种方式初始化Volume： 不指定主机上的目录 1docker run -it --name btown-jenkins -v /data btown-jenkins bash 此命令会将/data挂载到容器中，并绕过联合文件系统，我们可以在主机上直接操作该目录，通过docker inspect命令找到Volume在主机上的存储位置： 1docker inspect -f &#123;&#123;.Volumes&#125;&#125; btown-jenkins 类似的输出为： 1map[/data:/var/lib/docker/vfs/dir/cde167197ccc3e138a14f1a4f...b32cec92e79059437a9] 指定主机上的目录： 1docker run -it --name btown-jenkins -v /home/data:/data btown-jenkins bash 命令将挂载主机的/home/data目录到容器内的/data目录上 通过Volume挂载关键数据目录后，就可以解决上面出现的问题了 其他常用命令 查看所有镜像：docker images 删除镜像：docker rmi xxx 查看所有容器：docker ps -a 删除容器：docker rm xxx 退出容器：exit，CTRL+D 重新连接容器： docker attach xxx docker exec -it xxx bash 差别：使用docker exec连接容器后，现执行exit退出容器，容器不会停止 启动|停止容器：docker start|stop DockerFile脚本语言Dockerfile 是一个类似 Makefile 的工具，主要用来自动化构建镜像。 先看一个例子：123456789101112131415161718192021222324252627# 系统版本 由于需要glibc-2.14版本以上，所以要使用centos:7FROM centos:7.3.1611# 作者信息MAINTAINER liuyang@58ganji.com# 安装基础库RUN yum -y updateRUN yum -y install wget# 安装 Oracle Java 7 JDK，安装成功的目录：/usr/java/jdk1.7RUN mkdir -p /data0/softADD ./jdk-7u80-linux-x64.rpm /data0/soft/jdk-7u80-linux-x64.rpmRUN rpm -ivh /data0/soft/jdk-7u80-linux-x64.rpm# 设置jdk的环境变量ENV JAVA_HOME /usr/java/jdk1.7.0_80ENV PATH $PATH:$JAVA_HOME/jre/bin:$JAVA_HOME/bin# 复制ssh keyCOPY ./ssh.tar /data0/soft/ssh.tarRUN cd /data0/soft &amp;&amp; tar xvf ssh.tarRUN cp -r -f /data0/soft/.ssh /var/lib/jenkins/RUN chmod -R 777 /var/lib/jenkins/.sshEXPOSE 8080ENTRYPOINT service jenkins start 格式Dockerfile 中所有的命令都是以下格式：INSTRUCTION argument 指令(INSTRUCTION)不分大小写，但是推荐大写。 FROM 命令FROM &lt;image name&gt;，例如 FROM ubuntu 所有的 Dockerfile 都用该以 FROM 开头，FROM 命令指明 Dockerfile 所创建的镜像文件以什么镜像为基础，FROM 以后的所有指令都会在 FROM 的基础上进行创建镜像；可以在同一个 Dockerfile 中多次使用 FROM 命令用于创建多个镜像。 MAINTAINER 命令MAINTAINER &lt;author name&gt; 用于指定镜像创建者和联系方式。 RUN 命令RUN &lt;command&gt; 用于容器内部执行命令。每个 RUN 命令相当于在原有的镜像基础上添加了一个改动层，原有的镜像不会有变化。 ADD 命令ADD &lt;src&gt; &lt;dst&gt; 用于从将 &lt;src&gt; 文件复制到 &lt;dst&gt;文件：&lt;src&gt; 是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件 url，&lt;dst&gt; 是容器中的绝对路径。 注意：如果源文件是压缩文件（如.tar,.zip等等），会自动解压，如果不想自动解压，可以使用copy命令 COPY指令COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。 ENV 命令设置环境变量，参考 export 的用法咧：ENV LC_ALL en_US.UTF-8 EXPOSE 命令EXPOSE &lt;port&gt; [&lt;port&gt;…] 命令用来指定对外开放的端口。 1234EXPOSE 80EXPOSE 8080# 不推荐这样写，会固定死映射端口，最好通过创建容器时来指定EXPOSE 8000:8080 注意：除EXPOSE 8000:8080是提前指定了映射端口外，其他的相当于一个声明而已，具体端口映射还是在创建容器时指定的。 ENTRYPOINT 命令ENTRYPOINT command param1 param2 用来指定启动容器时，执行的命令 生成DockerFile的流程由于每个重新执行一次DockerFile文件的时间很长，所以写DockerFile的最佳方案： 创建一个最初的容器，再执行成功一个命令后，就添加到DockerFile文件里，等全部OK后，DockerFile也就创建完了 再整体执行DockerFile文件，查看创建镜像是否成功 Docker的容器的性能具体内容请查看：docker与虚拟机性能比较 docker比虚拟机的优势： docker有着比虚拟机更少的抽象层 docker利用的是宿主机的内核，而不需要Guest OS docker计算效率与主机一样，没有损耗，但虚拟机的计算能力损耗在50%左右 docker与虚拟机内存访问效率要高 docker与虚拟机启动时间及资源耗费要高 docker的劣势： 资源隔离方面不如虚拟机，docker是利用cgroup实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源 安全性问题。docker目前并不能分辨具体执行指令的用户，只要一个用户拥有执行docker的权限，那么他就可以对docker的容器进行所有操作，不管该容器是否是由该用户创建。比如A和B都拥有执行docker的权限，由于docker的server端并不会具体判断docker cline是由哪个用户发起的，A可以删除B创建的容器，存在一定的安全风险。 docker目前还在版本的快速更新中，细节功能调整比较大。一些核心模块依赖于高版本内核，存在版本兼容问题 参考 Docker 教程 一图看尽 docker 容器文件系统 docker与虚拟机性能比较","categories":[{"name":"Server","slug":"Server","permalink":"https://handsomeliuyang.github.io/categories/Server/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://handsomeliuyang.github.io/tags/jenkins/"},{"name":"docker","slug":"docker","permalink":"https://handsomeliuyang.github.io/tags/docker/"}]},{"title":"如何设计高保真原型图","slug":"Axure设计原型图","date":"2017-03-14T08:00:00.000Z","updated":"2017-03-20T05:27:20.000Z","comments":true,"path":"2017/03/14/Axure设计原型图/","link":"","permalink":"https://handsomeliuyang.github.io/2017/03/14/Axure设计原型图/","excerpt":"","text":"背景在设计“专项测试平台项目”的需求文档时，按传统的word设计需求文档带来的问题： 文档不够详细，没有交互，没有各种出错的处理情况 没有一个平台的功能流程全貌，无法提前给上级审核 需求评审的效率很低 通过分析，发现主要原因是出在需求文档上，现在的静态word文档，能表达的信息很有限，那有没有更好的方式。这就是今天要分享的：高保真原型图。 注意：实现高保真原型图的软件有很多，完全不限于Axure 高保真原型图Axure意义我们可以通过房屋装修来理解，在房屋真正开始装修之前，我们要做很多的工作，如看建材，看家电，看家具，看设计师做的效果图。这些都是为了在开始真正装修之前，尽最大可能去了解最终效果是什么样子，是不是我们想要的，因为一旦开始装修，就很难去更改。 这时如果能把想要装修的房子变成一个真实的样板间，我们看提前看到所有的效果，家电，家具等等，而且还能进行体验，提出改进意见，满意后，才真正开始装修。 高保真原型图Axure就是制作这个真实样板间的工具。总结几点好处： 实现功能与视觉上的统一，通过实际演示，减少口头沟通 领导与用户可以提前体验最终效果，可以提前收到他们的反馈意见 开发者终于可以了解你想要什么。以前用文档与图片无法解释清楚的需求，现在可以很容易的让开发者理解 Axure版本 使用的是AxureRP Pro 7.0版本，同时下载注册机 下载对应版本的汉化包 Axure的主要功能线框图+设计仅仅使用方块，占位符，形状和文本设计的，称之为线框图，如下图所示： 对线框图进行视觉美化设计后，称之为高保真原型图，如下图所示： 线框图与高保真原型图的差别，仅仅是真实程序不一样而已 母版母版可以理解为PPT里的母版，是可以复用部分。设计网站时，网站的导航栏，Footer等等都是通用的组件，每个页面都有，这时可以创建一个母版，实现复用，如下所示： 元件库原生自带的元件库只适合做线框图，要做手机app的原型图设计的话，工作量会比较大，这时可以导入其他的元件库，如下导入了ios8组合元件库： 动态面板 上面的功能模块，在原型图里实现，就可以使用动态面板，动态面板是指在同一个区域里，有多种展示形态： 控件连线通过如下可以把两个控件进行连接： 交互给控件添加交互，就是给此控件添加：事件(event)，用例(case)，动作(action)。 事件，如鼠标点击事件，鼠标移入时，鼠标移出时等等 用例，发生事件后，做什么样的业务逻辑判断 动作，即这个用例下，执行什么下的动作 如下创建的交互： 事件的种类： 用例与其条件： 常用的动作有： 打开新的链接 动态面板切换 设置显示/隐藏 浏览器展示直接可以在预览，但为了不出现显示问题，建议使用chrome浏览器进行预览 文档每个控件可以添加文档 当前页面也可以添加文档 合作 通过AxShare可以实现合作编辑 通过版本管理来保存原文件，进行合作编辑 工具对比 Axure PR 学习成本也非常高 专业的原型设计工具 可以实现很复杂的交互 官网 Mockplus 有免费版本，简洁高效，关注设计，而非工具 官网 更多请点击 谁来制作高保真原型产品经理与设计师是高保真原型的制作者。（技术做支持） 产品经理负责收集各方面的需求，在平衡各种资源后，确定最值得开发的产品的功能 设计师按照这个功能的规划制作视觉体现，然后产品经理和设计师一起，将功能点、设计图和交互流程一起合并为高保真原型。 参考 Axure RP高保真网页原型制作","categories":[{"name":"设计","slug":"设计","permalink":"https://handsomeliuyang.github.io/categories/设计/"}],"tags":[{"name":"axure","slug":"axure","permalink":"https://handsomeliuyang.github.io/tags/axure/"}]},{"title":"前端学习系列2：从移动端的角度学习与分析Redux","slug":"前端学习系列：从移动端的角度学习与分析Redux","date":"2017-01-15T08:00:00.000Z","updated":"2017-02-20T12:24:12.000Z","comments":true,"path":"2017/01/15/前端学习系列：从移动端的角度学习与分析Redux/","link":"","permalink":"https://handsomeliuyang.github.io/2017/01/15/前端学习系列：从移动端的角度学习与分析Redux/","excerpt":"","text":"遇到的问题通过上往篇文章前端学习系列：基于React的Robot框架的踩坑之旅介绍，已经搭建起React的整体环境，但在进行具体业务开发时，还是遇到如下问题： 所有界面操作，如网络请求，点击事件等等都在同一个组件里完成，出现组件过于庞大的问题 子组件与父组件只能通过回调方法进行通信，没有一个消息总线机制（如：子组件想决定框架Master里的title，除了通过回调方法，尽没有找到其他方法） 无法进行单元测试，基本只能整体测试，无法对其的界面与数据进行分别测试 关键日志无法添加，就像Android开发里也一样，关键日志只能通过手动去添加 Redux动机通过调研，最终选择Redux。Redux主要用来解决如下问题： 界面的变化在React理解为state的变化，当功能复杂时，state的变化非常之多，state在什么时候，由于什么原因，如何变化已然不受控制。这时我们遇到问题，进行重现也变的非常困难。—- 做Android开发，也有同感，当QA遇到一个比较难复现的bug时，RD就很难定位问题。 React开发时，state的变化与异步是混在一起的（异步可以理解为业务逻辑，如用户交互，网络请求，具体业务功能等等）。只有把state的变化与异步进行分离，才能很好的进行管理。—- 客户端开发，为什么会有MVC，MVVM，MVP等等框架，其实也是同样的出发点，尽量把展示与数据进行分离 运行todos例子 下载redux的原码。github的地址 安装node，注意node的版本号一定要&gt;4.0。因为0.x版本不支持es6等等高级语法。或者进行node版本升级，node升级教程 进入todos的目录，执行以下命令，安装dependencies 1node install 运行 1node start Redux实现 注意：项目中的代码都是以redux的官方例子todos，为基础进行改造的 Redux里的state其实就是一个对象，或者可以理解为一个json数据，如下所示： 12345678910111213&#123; todos: [ &#123; text: 'Eat food', completed: true &#125;, &#123; text: 'Exercise', completed: false &#125; ], visibilityFilter: 'SHOW_COMPLETED'&#125; Redux的核心思想很容易理解，只有三大概率：Action，Reducer，Store。其关系如下： React组件通过Store监听state的变化 调用方通过调用Store的dispatch()方法发送动作action Store通过Reducer把action对象转换为state对象 Store更新内部保存的state对象，并广播监听者进行界面刷新与变化 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import React, &#123;Component&#125; from 'react'import &#123; render &#125; from 'react-dom'import &#123; createStore &#125; from 'redux'// reducers，用来把action转换为stateconst reducers = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return &#123; todos: [ ...state, &#123; text: action.text &#125; ] &#125; default: return state &#125;&#125;// 创建store，全局只有一个store单例const store = createStore(reducers)class App extends Component &#123; constructor(props) &#123; super(props); // 当前组件的state的默认值 this.state = &#123;todos:[]&#125;; // 对state进行订阅 store.subscribe(()=&gt;&#123; let reduxState = store.getState(); console.log(\"redux's state\", reduxState); let currentTodos = store.getState().todos; if (this.state.todos !== currentTodos) &#123; this.setState(&#123;todos:currentTodos&#125;); &#125; &#125;); &#125; addTodo = (text) =&gt; (&#123; type: 'ADD_TODO', text &#125;); render()&#123; let input; const &#123; todos &#125; = this.state; return ( &lt;div&gt; &lt;div&gt; &lt;form onSubmit=&#123;e =&gt; &#123; e.preventDefault() if (!input.value.trim()) &#123; return &#125; // 发送action store.dispatch(this.addTodo(input.value)) input.value = '' &#125;&#125;&gt; &lt;input ref=&#123;node =&gt; &#123; input = node &#125;&#125; /&gt; &lt;button type=\"submit\"&gt; Add Todo &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;ul&gt; &#123;todos.map(todo =&gt; &lt;li key=&#123;todo.text&#125;&gt; &#123;todo.text&#125; &lt;/li&gt; )&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;render( &lt;App /&gt;, document.getElementById('root')) 运行效果如下： Redux扩展reducer的拆分reducer的作用是把action转换为state，当app变大后，需要对reducer进行拆分。 redux的整体特点： Store里保持的state是整体程序app的所有状态 每个action只是处理某一种行为 reducer的最简单的拆分方式，就是按不同的type类弄进行拆分 reducer拆分后的代码如下： 1234567891011121314151617181920212223242526const reducer_todos = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...state, &#123; text: action.text &#125; ] default: return state &#125;&#125;const initialState = &#123; todos:[]&#125;const reducer_root = (state = initialState, action) =&gt; &#123; return Object.assign(&#123;&#125;, state, &#123; todos: reducer_todos(state.todos, action) &#125;);&#125;// 创建store，全局只有一个store单例const store = createStore(reducer_root) Object.assign()用于拷贝两个对象的值，state对象是不能被修改。不然很容易出现不可预测的异常 reducer_root处理好整体拆分后，每个子reducer就只需要处理自己的数据转换。其他的数据自动继承 问题：由于所有界面的state都直接保存在内存里，当某界面离开后，其数据还是会一直保留在Store当中？处理方案：如一些页面的数据比较多，同时是不常用的界面，可以在退出此页面时，发送一个action，对数据进行清除。 combineReducers(reducers)上面的reducer的拆分方式都是一样的代码，可以提取api对外提供。其实现原理与上面类似，修改后的代码如下： 1234567891011121314151617181920const todos = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...state, &#123; text: action.text &#125; ] default: return state &#125;&#125;const reducer_root = combineReducers(&#123; todos&#125;);// 创建store，全局只有一个store单例const store = createStore(reducer_root) combineReducers()方法处理了三个功能： 生成state的初始值 通过方法名，自动生成key 自动传入state, action参数，并调用方法，重新生成state 调用与监听优化上面的redux的使用方法有如下问题： 会对使用者暴露store对象，store只能在一处初始化，需要传入到每个子组件，如果都是通过组件的props来传递，这个就很麻烦，尤其是当子view及层级比较多的时候 业务方每次都要进行监听，并进行数据转换，把redux的state转换为React的state对象，转换过程，要考虑一些性能问题，由于只要有一个子数据变化，所有监听者都会被触发通知，为了减少无用界面刷新，要做一些特殊处理。 解决方案：进行封装 store的传递封装，React里给组件传递对象，除了使用props属性外，还提供了一个全局传递方案：Context。具体请查看 包装一个容器组件，里面封装监听redux，并进行数据转换的工作 改进后的流程图： react-redux在学习react-redux时，需要先了解一下容器组件与展示组件的概念。 技术上讲你可以直接使用 store.subscribe() 来编写容器组件。但不建议这么做因为就无法使用 React Redux 带来的性能优化。也因此，不要手写容器组件，都是使用 React Redux 的 connect() 方法来生成。 react-redux的作用就是上面的解决方案的具体实现，我们看一下使用了react-redux的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import React, &#123;Component&#125; from 'react'import &#123; render &#125; from 'react-dom'import &#123; createStore, combineReducers &#125; from 'redux'import &#123; Provider, connect &#125; from 'react-redux'// import App from './components/App'// import reducer from './reducers'// reducers，用来把action转换为stateconst todos = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...state, &#123; text: action.text &#125; ] default: return state &#125;&#125;const reducer_root = combineReducers(&#123; todos&#125;);// 创建store，全局只有一个store单例const store = createStore(reducer_root)// actionsconst addTodo = (text) =&gt; (&#123; type: 'ADD_TODO', text&#125;);class App extends Component &#123; constructor(props) &#123; super(props); // 当前组件的state的默认值 // this.state = &#123;todos:[]&#125;; // 对state进行订阅 // store.subscribe(()=&gt;&#123; // let reduxState = store.getState(); // console.log(\"redux's state\", reduxState); // let currentTodos = store.getState().todos; // if (this.state.todos !== currentTodos) &#123; // this.setState(&#123;todos:currentTodos&#125;); // &#125; // &#125;); &#125; render()&#123; // React的界面布局 let input; const &#123; todos, addTodo &#125; = this.props;//this.state; return ( &lt;div&gt; &lt;div&gt; &lt;form onSubmit=&#123;e =&gt; &#123; e.preventDefault() if (!input.value.trim()) &#123; return &#125; // 发送action // store.dispatch(this.addTodo(input.value)) addTodo(input.value); input.value = '' &#125;&#125;&gt; &lt;input ref=&#123;node =&gt; &#123; input = node &#125;&#125; /&gt; &lt;button type=\"submit\"&gt; Add Todo &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;ul&gt; &#123;todos.map(todo =&gt; &lt;li key=&#123;todo.text&#125;&gt; &#123;todo.text&#125; &lt;/li&gt; )&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;const mapStateToProps = (state, ownProps) =&gt; &#123; console.log('state value is ', state); return &#123; todos: state.todos &#125;;&#125;;App = connect(mapStateToProps, &#123; addTodo&#125;)(App);render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 要点： react-redux通过提供Provider与connect()方法实现接入层的解耦 Provider的作用比较简单，用来实现全局的store对象的传递，里面的实现原理就是通过React的Context来实现的，如下面就是Provider的原码 connect()比较复杂，其主要是两件事情： 把redux的state转换为React组件的props属性 把action方法进行dispatch包装，再通过React组件的props属性传给React组件 1234567891011121314151617181920212223242526272829303132333435class Connect extends Component &#123; initSubscription() &#123; if (shouldHandleStateChanges) &#123; const subscription = this.subscription = new Subscription(this.store, this.parentSub) const dummyState = &#123;&#125; subscription.onStateChange = function onStateChange() &#123; this.selector.run(this.props) if (!this.selector.shouldComponentUpdate) &#123; subscription.notifyNestedSubs() &#125; else &#123; this.componentDidUpdate = function componentDidUpdate() &#123; this.componentDidUpdate = undefined subscription.notifyNestedSubs() &#125; this.setState(dummyState) &#125; &#125;.bind(this) &#125; &#125; render() &#123; const selector = this.selector selector.shouldComponentUpdate = false if (selector.error) &#123; throw selector.error &#125; else &#123; return createElement(WrappedComponent, this.addExtraProps(selector.props)) &#125; &#125;&#125; 把redux的state转换为react的props，比转换为react的state属性的好处： 对于React组件而言，外界有仅只能通过组件的props对此组件进行控制，内部的state不对外进行暴露，一切都是通过外界传入的props参数来进行控制，真正实现业务与界面分离解耦 组件可以做到与Redux解耦，组件能快速脱离Redux，并为一个共用组件 Middleware中间件 中间件：提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。那么利用中间件，我们就可以做很多的事情，如： 网络请求 实现异步（此异步与android里的线程有差异） 日志记录 。。。 中间件的特点： action的发送是顺序发送的，即第一个中间件处理后，才会传给第二个中间件处理。 中间件的注册是有顺序的 中间件可以决定是否再传递action 通过学习：中间件实现的具体演化过程可以了解javascript的一些语言特点：Monkey-Patching。相当于Java里的hook，对对象里方法进行proxy。但具体原因不一样： javascript的Monkey-Patching是利用javascript的函数也是一个变量，可以被修改特点来实现的 java里的hook，是通过子类可以重写父类的方法来实现的。 Redux在实际项目中的好处我在Robot项目里，使用了Redux，我的体验有： 界面与业务分离，写界面时，不用思考业务流程是如何的，只要思考界面与数据的关系。 网络请求代码，业务逻辑与界面解耦 调试问题非常方便，不像之前需要大量添加console.log()。一般可以通过action，state的日志就可以分析出原因，是由后台数据问题，还是界面问题 可实现录制与回放—-此好处还没有实现 参考 Redux 中文文档 Redux redux例子：real-world","categories":[{"name":"前端","slug":"前端","permalink":"https://handsomeliuyang.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"https://handsomeliuyang.github.io/tags/React/"},{"name":"Robot","slug":"Robot","permalink":"https://handsomeliuyang.github.io/tags/Robot/"},{"name":"nodejs","slug":"nodejs","permalink":"https://handsomeliuyang.github.io/tags/nodejs/"}]},{"title":"前端学习系列：基于React的Robot框架的踩坑之旅","slug":"Robot框架-Nodejs+Express+React+MaterialUI","date":"2016-12-30T05:00:00.000Z","updated":"2017-01-05T02:45:37.000Z","comments":true,"path":"2016/12/30/Robot框架-Nodejs+Express+React+MaterialUI/","link":"","permalink":"https://handsomeliuyang.github.io/2016/12/30/Robot框架-Nodejs+Express+React+MaterialUI/","excerpt":"","text":"背景上次给大家介绍Robot平台框架，其特点： 由nodejs+express+react+bootstrap实现 UI使用开源UI库：charisma React通过browserify+babel打包处理 效果如下： 其中遇到的一些问题： 前端界面框架没有真正的React化，只使用很少一部分，html页面里，还有大量的js引用配置，css引用配置 123456789101112131415161718192021222324252627282930313233343536373839// html引用css部分&lt;link href=\"../../other_js_lib/charisma/css/charisma-app.css\" rel=\"stylesheet\"&gt;&lt;link href='../../other_js_lib/charisma/bower_components/fullcalendar/dist/fullcalendar.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/bower_components/fullcalendar/dist/fullcalendar.print.css' rel='stylesheet' media='print'&gt;&lt;link href='../../other_js_lib/charisma/bower_components/chosen/chosen.min.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/bower_components/colorbox/example3/colorbox.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/bower_components/responsive-tables/responsive-tables.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/bower_components/bootstrap-tour/build/css/bootstrap-tour.min.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/css/jquery.noty.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/css/noty_theme_default.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/css/elfinder.min.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/css/elfinder.theme.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/css/jquery.iphone.toggle.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/css/uploadify.css' rel='stylesheet'&gt;&lt;link href='../../other_js_lib/charisma/css/animate.min.css' rel='stylesheet'&gt;// html中大量引用js的部分&lt;!-- select or dropdown enhancer --&gt;&lt;script src=\"../../other_js_lib/charisma/bower_components/chosen/chosen.jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- plugin for gallery image view --&gt;&lt;script src=\"../../other_js_lib/charisma/bower_components/colorbox/jquery.colorbox-min.js\"&gt;&lt;/script&gt;&lt;!-- notification plugin --&gt;&lt;script src=\"../../other_js_lib/charisma/js/jquery.noty.js\"&gt;&lt;/script&gt;&lt;!-- library for making tables responsive --&gt;&lt;script src=\"../../other_js_lib/charisma/bower_components/responsive-tables/responsive-tables.js\"&gt;&lt;/script&gt;&lt;!-- tour plugin --&gt;&lt;script src=\"../../other_js_lib/charisma/bower_components/bootstrap-tour/build/js/bootstrap-tour.min.js\"&gt;&lt;/script&gt;&lt;!-- star rating plugin --&gt;&lt;script src=\"../../other_js_lib/charisma/js/jquery.raty.min.js\"&gt;&lt;/script&gt;&lt;!-- for iOS style toggle switch --&gt;&lt;script src=\"../../other_js_lib/charisma/js/jquery.iphone.toggle.js\"&gt;&lt;/script&gt;&lt;!-- autogrowing textarea plugin --&gt;&lt;script src=\"../../other_js_lib/charisma/js/jquery.autogrow-textarea.js\"&gt;&lt;/script&gt;&lt;!-- multiple file upload plugin --&gt;&lt;script src=\"../../other_js_lib/charisma/js/jquery.uploadify-3.1.min.js\"&gt;&lt;/script&gt;&lt;!-- history.js for cross-browser state change on ajax --&gt;&lt;script src=\"../../other_js_lib/charisma/js/jquery.history.js\"&gt;&lt;/script&gt;&lt;!-- application script for Charisma demo --&gt;&lt;script src=\"../../other_js_lib/charisma/js/charisma.js\"&gt;&lt;/script&gt; html过多，每个一个界面就会有一个html页面 React界面大的方向使用的是Component开发模式，但每个组件内，还是大最使用最原生的方式开发，下面是其中一个组件的render()方法内部代码： 界面很不好，由于css与js逻辑代码分离，在没有缓存时，经常出现先看到没有样式的界面，再看到整体界面，整体视觉效果很不好 使用的是browserify的express的中间件：browserify-middleware，虽然能解决开发期间每次执行手动执行转换的功能，但问题是修改界面后，每次都手动需新才行。 没有适配移动端，在手机版本上的体验很差 还有很多其他的，都是由上面的问题衍生出来的 调研为了解决上面的问题，花了几天时间进行调研，主要的调研点： browserify是否可以对css进行模块化支持？ 结论：webpack更加合适 webpack的使用，有没有类似browserify-middleware功能？ 结论：webpack-dev-server 双服务器配置：nodejs+express与webpack-dev-server的理解与如何工作？ 结论：思维需要变化，下面会具体介绍 React的UI库：Material-UI的使用？ 结论：官网demo例子只有基本组件的使用，学了后，还是无法创造出想要的效果 Robot最新框架技术集 后端： Nodejs nodemon Express 前端: React react-router Material-UI react-tap-event-plugin 打包工具： webpack style-loader babel-loader webpack-dev-server babel babel-preset-es2015 babel-preset-react babel-preset-stage-1 框架目录结构 框架界面 具体技术点后端Server 使用nodejs+express创建后台服务。网上很多教程 关键点： server端的日志输出，把所有请求都通过日志输出 1234// 通过使用给express里添加morgan，就可以实现var logger = require('morgan');var app = express();app.use(logger('dev')); 实现Server的404异常，利用express的中间件机制原理，实现404找不到页面异常 123456789101112131415161718192021222324252627// 工具中间件app.use(logger('dev'));app.use(bodyParser.json());app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(cookieParser());// 业务中间件app.use('/', index);app.use('/users', users);// catch 404 and forward to error handlerapp.use(function(req, res, next) &#123; var err = new Error('Not Found'); err.status = 404; next(err);&#125;);// error handlerapp.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error');&#125;); nodemon实现改动server端代码后，实现自动重新加载 webpack打包配置高级特性在写React模块时，为了更加方便编写，使用了一些高级特性： ES6语法 12345678910// es6的模块化引入import React, &#123;Component&#125; from 'react';// es6的类定义class Master extends Component &#123;&#125;// 模块化导出export default XXX; JSX标记 12345return ( &lt;div&gt; ... &lt;/div&gt;); class类的成员变量定义 123456789101112131415// 注意：在es6的规范中，并不支持成员变量，static变量直接在class里定义，只能如下定义class Master extends Component &#123; constructor()&#123; this.state = &#123; navDrawerOpen: false &#125;; &#125;&#125;// 但我们希望使用下面的语法规则class Master extends Component &#123; state = &#123; navDrawerOpen: false &#125;;&#125; 上面的高级特性，现在主流的浏览器都还不支持，为了使用，我们就需要进行转换： webpack bable-loader // 用于加载babel bable babel-preset-es2015 // 转换es6语法 babel-preset-react // 转换jsx语法 babel-preset-stage-1 // 转换成员变量语法 开发环境配置 通过自己搭后台服务与webpack的watch来实现 webpack-dev-server，HotModuleReplacementPlugin实现热更新 — 推荐方式 webpack-dev-server.config.js的具体配置(webpack-dev-server配置)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const webpack = require('webpack');const path = require('path');// 开发期间把www做为了输出目录，不与正式环境情况发生冲突const buildPath = path.resolve(__dirname, 'src/www');module.exports = &#123; entry: [ 'webpack/hot/dev-server', // 热修复配置，这个需要一起合并到app.js里 path.resolve(__dirname, 'src/app/app.js') // app的入口 ], output: &#123; path: buildPath, filename: 'app.js' //publicPath: buildPath // 不用特别指定publicPath路径 &#125;, // 这个是webpack-dev-server的运行参数 devServer: &#123; contentBase: path.resolve(__dirname, 'src/www'), hot:true, // 热修复 inline: true, // 使用热修复，必须是inline模式 port: 8080 // 创建的服务器的port，自由配置 &#125;, resolve: &#123; extensions: ['', '.js', '.jsx', '.css', '.json'] &#125;, plugins: [ // 让webpack-dev-server支持热更新 new webpack.HotModuleReplacementPlugin() ], module: &#123; loaders: [ &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/, query: &#123; \"presets\": [ \"react\", // 为了支持jsx的语法 \"es2015\", // 为了支持es6的语法 \"stage-1\" // 为了支持class的成员变量与静态变量 ] &#125; &#125;, &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125; ] &#125;&#125;; 通过下面命令运行webpack-dev-server，开发环境配置完成，即可实现修改了js文件后，主动推送更新浏览器 12345678// 先在package.json里配置&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;nodemon ./bin/www&quot;, &quot;browser:development&quot;: &quot;webpack-dev-server --config client/webpack-dev-server.config.js --progress --colors --inline&quot;&#125;// 命令行里运行npm run browser:development 通过这种方式启动的webpack-dev-server后，通过ctrl-z能停掉服务，但无法释放所占用的8080端口号，需求如下操作，kill掉此端口的占用，才能再次启动。 1234// 查找端口被哪些服务占用lsof -i:8080// kill掉此进程kill -9 进程pid 前端框架基于React的开发思路变化传统开发模式： React开发模式： app前端入口12345678910111213141516171819202122import React from 'react';import &#123;render&#125; from 'react-dom';import injectTapEventPlugin from 'react-tap-event-plugin';import &#123;Router, browserHistory&#125; from 'react-router';import &#123;createHashHistory&#125; from 'history';import AppRoutes from './AppRoutes.js';// Needed for onTouchTap// http://stackoverflow.com/a/34015469/988941injectTapEventPlugin();// &#123;/*没有弄懂这两个配置参数*/&#125;render( &lt;Router history=&#123;browserHistory&#125; onUpdate=&#123;() =&gt; window.scrollTo(0, 0)&#125; &gt; &#123;AppRoutes&#125; &lt;/Router&gt;, document.getElementById('app')); app的入口职责很简单： 路由配置 通用处理，如material-ui库里的事件初始化：injectTapEventPlugin(); app的此入口相当于Android里的Application app的前端路由在android里，一个界面跳转到另外的界面，是通过协议intent与startActivity()方法来实现跳转，其中的核心实现是由系统自己封装掉了 在前端，界面之前跳转的协议都是URL，再通过window.location.href重新向server请求并加载新页面。 在React的模式下，跳转协议也是URL，但这个URL不用经过server请求，而是重新加载新模块实现，如下图所示： 要想实现此效果，不使用React-Router开源框架，我们的写法为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var React = require('react');var About = React.createClass(&#123; render: function () &#123; return( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;p&gt;这里将会出现N多介绍文字balabala&lt;/p&gt; &lt;/div&gt; );&#125;&#125;);var blogs = React.createClass(&#123; render: function () &#123; return( &lt;div&gt; &lt;h2&gt;blogs&lt;/h2&gt; &lt;a href=\"＃\"&gt;文章A&lt;/a&gt; &lt;br /&gt; &lt;a href=\"＃\"&gt;文章B&lt;/a&gt; &lt;br /&gt; &lt;a href=\"＃\"&gt;文章C&lt;/a&gt; &lt;br /&gt; &lt;a href=\"＃\"&gt;文章D&lt;/a&gt; &lt;/div&gt; );&#125;&#125;);var Home = React.createClass(&#123; render: function () &#123; return( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;p&gt;这里是首页&lt;/p&gt; &lt;/div&gt; );&#125;&#125;);var App = React.createClass(&#123; render () &#123; var Child; switch (this.props.route) &#123; case 'about': Child = About; break; case 'blogs': Child = blogs; break; default: Child = Home; &#125; return ( &lt;div&gt; &lt;h1&gt;App&lt;/h1&gt; &lt;Child/&gt; &lt;/div&gt; ) &#125;&#125;);function render () &#123; var route = window.location.hash.substr(1); React.render(&lt;App route=&#123;route&#125; /&gt;, document.body);&#125;window.addEventListener('hashchange', render);render(); 这样实现，也比较容易，但当我们要进行复杂的路由时，就会变的非常麻烦了，所以我们需要使用react-router。 我们的路由配置AppRoutes.js的代码如下： 12345678910111213import React from 'react';import &#123;Route, IndexRoute&#125; from 'react-router';import Master from './components/Master'import Home from './components/pages/Home';const AppRouters = ( &lt;Route path=\"/\" component=&#123;Master&#125;&gt; // 其Master为整体框架 &lt;IndexRoute component=&#123;Home&#125; /&gt; // Home表示首页，注意是：嵌入到框架里的部份 &lt;/Route&gt;);export default AppRouters; 更多配置请点击：ReactRouteConfig Master.js框架的实现Material-UI理解 官网 Material-UI提供了一套组件库。具体请点击 Material-UI还提供了一套样式主题库，颜色库。具体请点击 Material-UI作用 使用其提供的组件，可以开发出与Android原生的Design设计库一致的效果 使用其样式及主题，统一所有的控件与界面的风格，方便统一风格切换 能方便PC，App的适配，提供的控件及源码里有适配的解决方案 对React-Native而言，方便统一PC，M，Android，Ios四端的风格样式 Master.js代码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import React, &#123;Component&#125; from 'react';// 使用Material-UI的控件import &#123;AppBar, MuiThemeProvider&#125; from 'material-ui';// 使用Material-UI的样式主题import &#123;getMuiTheme, colors, spacing&#125; from 'material-ui/styles';// 使用Material-UI对屏幕适配import withWidth, &#123;MEDIUM, LARGE&#125; from 'material-ui/utils/withWidth';// 封装的抽屉Drawerimport AppNavDrawer from './AppNavDrawer.js';// 用于对屏暮大小适配的包装模块import FullWidthSection from './FullWidthSection.js';// Material-UI主题const muiTheme = getMuiTheme();// 此框架页面的一些特殊样式，即样式主题无法满足的自定义部分const styles = &#123; appBar: &#123; position: 'fixed', // Needed to overlap t he examples zIndex: muiTheme.zIndex.appBar + 1, top: 0, left: 0, right: 0 &#125;, root: &#123; paddingTop: spacing.desktopKeylineIncrement, minHeight: 400, &#125;, content: &#123; margin: spacing.desktopGutter, &#125;, footer: &#123; backgroundColor: colors.grey900, textAlign: 'center', position: 'fixed', left:0, right:0 &#125;, p: &#123; margin: '0 auto', padding: 0, color: colors.lightWhite, maxWidth: 356, &#125;, p2: &#123; margin: '0 auto', padding: 0, paddingTop: '5px', color: colors.red800, maxWidth: 356, &#125;,&#125;;class Master extends Component &#123; // React控件的state初始值 // 所有的界面变化，都应该通过state来控件，而不是直接操作对应的dom元素 state = &#123; navDrawerOpen: false // 表明抽屉默认是关闭的 &#125;; // 处理Drawer的状态变化 handleChangeRequestNavDrawer = (open)=&gt; &#123; this.setState(&#123; navDrawerOpen: open &#125;); &#125;; // 成员变量，用于处理AppBar左边图片点击事件 handleTouchTapLeftIconButton = ()=&gt; &#123; this.setState(&#123; navDrawerOpen: !this.state.navDrawerOpen &#125;); &#125;; // 框架界面 render()&#123; return ( &lt;MuiThemeProvider&gt; // 这个是使用Material-UI必须要添加的，用于提供Material-UI主题样式 &lt;div&gt; &lt;AppBar onLeftIconButtonTouchTap=&#123;this.handleTouchTapLeftIconButton&#125; title=\"Robot\" style=&#123;styles.appBar&#125;/&gt; // 子素元位置 &#123; &lt;div style=&#123;muiTheme.prepareStyles(styles.root)&#125;&gt; &lt;div style=&#123;muiTheme.prepareStyles(styles.content)&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; &lt;/div&gt; &#125; &lt;AppNavDrawer onRequestChangeNavDrawer=&#123;this.handleChangeRequestNavDrawer&#125; open=&#123;this.state.navDrawerOpen&#125;/&gt; // 用于适配屏幕宽度的 &lt;FullWidthSection style=&#123;styles.footer&#125;&gt; &lt;p style=&#123;muiTheme.prepareStyles(styles.p)&#125;&gt; &#123;'58同城-用户增长部-无线技术部 '&#125; &lt;/p&gt; &lt;p style=&#123;muiTheme.prepareStyles(styles.p2)&#125;&gt; &#123;' Android组 '&#125; &lt;/p&gt; &lt;/FullWidthSection&gt; &lt;/div&gt; &lt;/MuiThemeProvider&gt; ); &#125;&#125;export default withWidth()(Master); 参考 React-Router React 实践记录 03 React router webpack material-ui express Static Properties in ES Class","categories":[{"name":"前端","slug":"前端","permalink":"https://handsomeliuyang.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"https://handsomeliuyang.github.io/tags/React/"},{"name":"Robot","slug":"Robot","permalink":"https://handsomeliuyang.github.io/tags/Robot/"},{"name":"nodejs","slug":"nodejs","permalink":"https://handsomeliuyang.github.io/tags/nodejs/"}]},{"title":"React实现MergeRequest管理","slug":"React实现MergeRequest管理","date":"2016-11-15T11:33:06.000Z","updated":"2017-01-05T02:45:45.000Z","comments":true,"path":"2016/11/15/React实现MergeRequest管理/","link":"","permalink":"https://handsomeliuyang.github.io/2016/11/15/React实现MergeRequest管理/","excerpt":"","text":"什么是ReactReact是一个前端框架，与其类似的有vue、angular 2.x等等。改变前端开发模式，让前端开发更加方便，让前端也使用面向对象的方案来开发。相关的一些特点可以看其官方文档 ES6,JSXJavaScript是一个统称，其标准的名称为：ECMAScript。ES6, ES5是两个不同的标准，现在的主流浏览器都完全支持ES5的语法，不支持最新标准ES6。ES6有很多的新特性，更适合面向对象的开发模式，如下所示： 123456789101112131415161718//es5var MyComponent = React.createClass(&#123; render: function() &#123; return ( &lt;div&gt;&lt;/&gt; ); &#125;&#125;);module.exports = MyComponent;//es6class MyComponent extends React.Component &#123; render() &#123; return ( &lt;div&gt;&lt;/&gt; ); &#125;&#125;export MyComponent Apply; ES6才支持模块化，ES5不支持，如下： 1234567import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')); 为了更方便开发及代码可读性，React里引入了模板语法：JSX，对比如下所示： 1234567891011121314151617181920212223// 使用JSX的写法class Hello extends React.Component &#123; render() &#123; return &lt;div&gt;Hello &#123;this.props.toWhat&#125;&lt;/div&gt;; &#125;&#125;ReactDOM.render( &lt;Hello toWhat=&quot;World&quot; /&gt;, document.getElementById(&apos;root&apos;));// 使用原生的Javascript的写法，注意同时使用了ES6class Hello extends React.Component &#123; render() &#123; return React.createElement(&apos;div&apos;, null, `Hello $&#123;this.props.toWhat&#125;`); &#125;&#125;ReactDOM.render( React.createElement(Hello, &#123;toWhat: &apos;World&apos;&#125;, null), document.getElementById(&apos;root&apos;)); ES6，JSX原生浏览器都不支持，就需要进行预编译（即转码）。React推荐使用Babel Babel是一个javascript的转换器，类似于gradle一样，支持各种插件。 FaceBook开发了一个用于转换JSX的Babel插件：babel-preset-react。 转换ES6的Babel插件为：babel-preset-es2015 更多请点周：Babel官网 为了让浏览器能运行React的代码，有两种方案： 一：实时编译，即让浏览器来编译，配置很简单，如下所示 1&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js\"&gt;&lt;/script&gt; 特点：这种方式为浏览器编译，因为实时编译会很慢，所以适合代码量比较小的 二：本地编译，即在Server端或本地提前编译好，这样就需要使用打包工具：browserify或webpack，React推荐使用Browserify（browserify官网）。下面使用的是延时方案，即用户访问资源时，才进行转换，如下所示： 12345678910111213141516var express = require('express');var browserify = require('browserify-middleware');var router = express.Router();// 把Browserify的环境切换为正式环境，其配置如下：/*process.env.NODE_ENV = 'production';browserify.settings.mode = 'production';*/var shared = ['react', 'react-dom'];router.get('/react/base_bundle.js', browserify(shared));// 为了不总是配置，直接进行环境配置browserify.settings.external = shared;browserify.settings.transform = 'babelify';router.get('/react/app_bundle.js', browserify('client/merge_manager/app.js')); 特点：方便，不用手动转换，除代码变动后的首次访问慢之外，没有性能问题，浏览器也不用转换运行 JSX的属性与Html的属性JSX是一个模块语法，是为了代码的可读性，但与html并不完全一样，其中最大的区别，有如下几点： 1.JSX支持表达式，但只支持一个表达式，不支持代码块： 1234567891011// 直接访问变量&lt;img src=&#123;user.avatarUrl&#125; /&gt;&lt;img src=&#123;'http://www.58.com' + '/a.png'&#125; /&gt;// 循环const todos = ['finish doc', 'submit pr', 'nag dan to review'];return ( &lt;ul&gt; &#123;todos.map((message) =&gt; &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125; &lt;/ul&gt;); 2.class属性由于是ES6里的关键字，所以需要使用className，如下： 12&lt;div className=\"button\"&gt;&lt;/div&gt; 3.html的属性的命名都是小写，但JSX里的属性都是驼峰命名法，如下所示： 12&lt;div className=\"xxx\" tabIndex=\"xxx\"&gt;&lt;/div&gt; 4.样式style，JSX把style当作字典对象来处理的，不能当字符来处理： 12&lt;div style=&#123;&#123;color:'blue', backgroundImage:'xxx'&#125;&#125;&gt;&lt;/div&gt; 模块化javascript的ES5是不支持模块的，即类不能分文件，即不能运行如下代码： 12345678910// CommonJs，nodejs才支持var React = require(&apos;react&apos;);var ReactDOM = require(&apos;react-dom&apos;);var TopBar = require(&apos;../common/header.js&apos;);var SideBar = require(&apos;../common/sidebar_nav.js&apos;);var Footer = require(&apos;../common/footer.js&apos;);// ES6才支持，ES5不支持import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;; 由于运行前，会使用Babel进行转换，所以React开发时，可以支持模块化，即可以使用Nodejs支持的CommonJs，也可以使用ES6的import模式。React推荐使用CommonJs的方式。 React与传统html开发思想对比传统开发html为界面，js为逻辑，分开开发，如下所示： 123456789&lt;body&gt; &lt;div&gt; ... &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // js代码&lt;/script&gt; 模板语言：EJS。为了插件业务数据，实现业务后台的MVC 123456789&lt;body&gt; &lt;div&gt; &lt;% if (!locals.username) &#123; %&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"/login\"&gt;&lt;%= locals.username %&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;% &#125; %&gt; &lt;/div&gt;&lt;/body&gt; React开发基于组件，一个控件的界面与逻辑都在一起，控件可以复用，与Native的开发模式比较类似，如下所示： 12345678910111213141516171819202122232425class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; // 组件已经与Dom上绑定完了 componentDidMount() &#123; &#125; // 组件与Dom解绑 componentWillUnmount() &#123; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; 上面使用的是ES6的语法，与Android的Fragment比较像，界面与业务逻辑都在此类里完成 上面的方法为React组件的生命周期方法 数据的获取方式：与传统方式不一样，而是通过Ajax来请求，与Native开发一下，界面与Service只通过接口来交互，但没有使用Server端的模板语言EJS React的生命周期 关键点： 1.我们开发的Api就是这些生命周期方法 2.this.props.xx，this.state.xx是两个数据相关的对象，共中props对象只读，而state是可以修改 123&lt;SideBar activeKey='merge_manager' /&gt; // 只能通过这种方式修改propsthis.setState(xxx) // 修改State数据，组件并进行刷新 3.在组件绑定到Dom里后，就可以通过jquery的方法，可以获取组件的dom元素 123456componentDidMount: function()&#123; $('#target-branch-select').chosen(&#123;width: \"100%\"&#125;); $('#assignee-select').chosen(&#123;width: \"100%\"&#125;); $('#title-select').chosen(&#123;width: \"100%\"&#125;); $('#author-select').chosen(&#123;width: \"100%\"&#125;);&#125;, React的生命周期与Android的生命周期对比1234567891011121314var InitEnvir = React.createClass(&#123; render: funcation()&#123; console.log('render...'); return ( &lt;div&gt; &lt;/div&gt; ); &#125;, componentDidMount: funcation()&#123; console.log('componentDidMount begin...'); this.setState(&#123;newData&#125;); console.log('componentDidMount end...'); &#125;&#125;); 上面代码的执行结果为： Android机制 React机制 render…componentDidMount begin… componentDidMount end… render… render…componentDidMount begin…render…componentDidMount end… 这个是Android机制与React机制最大的差别，Android的UI线程，有一个MainLoop队列。 React实现页面框架 DataTables框架表格数据使用的是DataTables组件(datatables官网) 由于数据量不大，使用的是前端排序，查询，过滤。数据量尽量不要超过1000。如果对于大数据，就需要Server进行配合 参考文档 React文档 React入门 (1)—使用指南（包括ES5和ES6对比）","categories":[{"name":"前端","slug":"前端","permalink":"https://handsomeliuyang.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"https://handsomeliuyang.github.io/tags/React/"},{"name":"Robot","slug":"Robot","permalink":"https://handsomeliuyang.github.io/tags/Robot/"},{"name":"nodejs","slug":"nodejs","permalink":"https://handsomeliuyang.github.io/tags/nodejs/"}]},{"title":"Android内核学习笔记：Android进程\\线程管理","slug":"Android内核学习笔记：Android进程线程管理","date":"2016-08-13T08:37:13.000Z","updated":"2016-08-14T04:42:22.000Z","comments":true,"path":"2016/08/13/Android内核学习笔记：Android进程线程管理/","link":"","permalink":"https://handsomeliuyang.github.io/2016/08/13/Android内核学习笔记：Android进程线程管理/","excerpt":"","text":"Android程序启动过程 ActivityManagerService与WindowManagerService在独立的进程里，与程序进度之间的通信通过Bindler进行 每个应用程序都是运行在独立的进程里的，进程与进程之间无法直接通信，每个进程里都一个JVM虚拟机，不能通过static进行通信 应用程序的进程是由ActivityManagerService通过Process.start(“android.app.ActivityThread”)创建的，进程创建后，会同时创建一个线程，这个线程就是我们所说的UIThread。 同一个进程里的Activity, Service等等四大组件都是运行在ActivityThread里，即UI线程里的。所以通常我们要在Service里创建一个Thread来真正执行后台程序 应用程序启动后，除了创建AcivityThread后，还会创建两个BindlerThread，作用就是用于与AMS，WMS进行交互的。 什么是线程Runnable是不是线程？ 不是，Runnable只是一个接口，用于创建线程的接口类 Thread是不是线程？ 不是，Thread只有在调用thread.start()方法后，才会创建一个Thread出来，之前的所有的初始化步骤都是在当前线程里执行的。Thread.start()方法如下： 12345public synchronized void start()&#123; checkNotStarted(); hasBeanStarted = true; VMThread.create(this, stackSize); // 这里才是真正创建一个CPU线程的地方&#125; 只有当VMThread.create()方法之后，才会创建一个真正的线程。 Android的UIThreadAndroid有四大组件：Activity，Service，ContentProvider，Broadcast。组各自的功能： Activity：界面，生命周期：onCreate(), … Service：后台服务，生命周期：onCreate(), … Broadcast：广播，生命周期：onReceive() ContentProvider：用于数据共享，生命周期：onCreate(), … 四大组件的运行哪个进程，哪个线程里呢？ 默认情况下：四大组件都是运行在以程序的包名命名的进程里， 四大组件都是运行在UIThread里，但注意：是其生命周期方法是运行在UIThread里。如ContentProvider的query()等等方法的执行线程要依调用方来决定 Service的生命周期是运行在UIThread里，我们需要执行的后台任务，需要创建一个子线程来执行 四大组件，Activity，Service，Broadcast都是需要时，系统进行创建，但ContentProvider例外，其是在应用进程启动时，就会开发创建。 Android的编程框架从开始接触Android开始，我们都是面向四大组件及四大组件的生命周期方法来进行编程。但学过C程序开发的都知道，应用程序都是从main()方法开始执行，再执行一个while()循环，不停接收事件，再处理事件的过程。Android的事件驱动流程： 由AMS创建应用程序进程，并创建UIThread，通过Looper.loop()，让UIThread进入事件驱动循环中 四大组件的生命周期方法，用户交互等等都当作Message，进入MessageQueue里，进入UIThread的事件驱动循环中。 ANR异常概念：ANR（Application No Response）用户点击屏幕后，如果5s没有处理完成此点击Event，就会报ANR异常 ANR发生的情况： 在UIThread里执行网络请求，IO操作等等耗时操作 UI绘制时间过长，也有可能造成ANR异常 ANR异常很多时候不是由一个耗时操作造成的，很多是由一组操作，如进行10000次SP读写操作。","categories":[{"name":"Android","slug":"Android","permalink":"https://handsomeliuyang.github.io/categories/Android/"}],"tags":[{"name":"Android内核学习笔记","slug":"Android内核学习笔记","permalink":"https://handsomeliuyang.github.io/tags/Android内核学习笔记/"}]},{"title":"Android签名的过程","slug":"2016-04-14-Android签名的过程","date":"2016-06-13T09:59:45.000Z","updated":"2016-08-13T08:21:13.000Z","comments":true,"path":"2016/06/13/2016-04-14-Android签名的过程/","link":"","permalink":"https://handsomeliuyang.github.io/2016/06/13/2016-04-14-Android签名的过程/","excerpt":"","text":"Android对apk签名过程Apk解压后的结构： 会生成一个META-INF的文件夹存放签名相关的数据：MANIFEST.MF WUBA_KEY.RSA WUBA_KEY.SF。此三个文件都是我们对unsigin.apk签名时生成的。 SHA1：安全哈希算法，对于长度小于2^64位的消息，SHA1会产生一个160位的消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据的完整性。在传输的过程中，数据很可能会发生变化，那么这时候就会产生不同的消息摘要。SHA1有如下特性：不可以从消息摘要中复原信息；两个不同的消息不会产生同样的消息摘要。 作用： 完整性，签过名后的Apk无法进行增删改，不然其签名都会不一样 自我校验，因为签过名后的Apk里有公钥，可以对其Apk进行自我校验，所以只需要Apk文件，在Android系统里就可以完成Apk的校验 并行性，校验可以并行进行，WUBA_KEY.RSA对WUBA_KEY.SF的校验与WUBA_KEY.SF对MANIFEST.MF校验可以并行执行 Android系统签验证机制系统验证流程刚好与签名过程相反： 了解签名流程后，能做的事情打批量包为了区分不同的渠道用于统计分析，apk里需要内置携带一个渠道号，各种方式的比较： 位置 经历的过程 特点 渠道号放在代码里 编译代码，编译res资源，编译Manifest文件，签名，生成Apk 非常慢，安全 放在res资源里 编译res资源，编译Manifest文件，签名，生成Apk 很慢，安全 放在AndroidManifest.xml文件里 编译Manifest文件，签名，生成Apk 慢，安全 放在asserts资源里 签名，生成Apk 快，安全 放在签名相关的META-INF文件夹里 生成Apk 非常快，不安全，可被修改 签名认证目的：防止apk被别人反编译，或者防止so文件被直接使用方案：由于Apk里携带了公钥，可以在so里，进行公钥对比，判断当前执行环境是不是在Apk里面。 Keystore文件生成过程由上面的签名过程得知，签名过程，需要有公钥和私钥，所以签名方法：1java -jar signapk.jar testkey.x509.pem testkey.pk8 update.apk update_signed.apk signapk.jar是Android源码包中的一个签名工具 通过signapk.jar这个可执行jar包，以“testkey.x509.pem”这个公钥文件和“testkey.pk8”这个私钥文件对“update.apk”进行签名，签名后的文件保存为“update_signed.apk” 而对应用App，我们是使用java里的命令：jarsigner。使用jarsigner要先生成keystore文件，使用如下：1keytool -genkey -v -keystore app.keystore -alias alias_name -keyalg RSA -validity 20000 -alias 后面跟的是别名这里是alias_name -keyalg 是加密方式这里是RSA -validity 是有效期这里是20000 -keystore 就是要生成的keystore的名称这里是app.keystore 使用jarsigner对unsign.apk进行签名：1jarsigner -verbose -keystore app.keystore -signedjar app_signed.apk app.apk alias_name -keystore: keystore的名称 -signedjar app_signed.apk: 指定签名后生成的APK名称 app.apk: 目标APK 修改Keystore的密码的影响使用keytool生成的keystore文件，我们称之为证书文件，里面存有用于签名apk的公钥及私钥，为了其安全，keystore有其自己本身的密码： storepass 指定密钥库的密码(获取keystore信息所需的密码) keypass 指定别名条目的密码(私钥的密码，即加密私钥的密码) 而我们可以修改keystore文件的storepass和keypass两种密码，都不影响对apk的签名，也不出现签名的apk不相同，因为keystore里面所包含的公钥和私钥是没有变化的。 keystore内部的信息是不会变化的：123456789101112131415161718- XXX.Keystore的信息： - Keystore 类型： JKS - Keystore 提供者： SUN - 您的 keystore 包含 1 输入 - 别名名称： XXXX - 创建日期： XXXX - 项类型: PrivateKeyEntry - 认证链长度： 1 - 认证 [1]: - 所有者:CN=XXX, OU=XXX, O=XXX, L=XXX, ST=XXX, C=XXX - 签发人:CN=XXX, OU=XXX, O=XXX, L=XXX, ST=XXX, C=XXX - 序列号:XXX - 有效期: XXX - 证书指纹: - MD5:XXX - SHA1:XXX - 签名算法名称:SHA1withRSA - 版本: 3 参考 Android系统代码签名验证机制的实现及安全性分析 Android签名总结","categories":[],"tags":[]},{"title":"58同城Hybrid框架的点点滴滴","slug":"58同城Hybrid框架的点点滴滴","date":"2016-03-24T07:28:51.000Z","updated":"2018-10-15T08:52:32.203Z","comments":true,"path":"2016/03/24/58同城Hybrid框架的点点滴滴/","link":"","permalink":"https://handsomeliuyang.github.io/2016/03/24/58同城Hybrid框架的点点滴滴/","excerpt":"","text":"Hybrid框架简介采用Hybrid模式的原因： 纯Native的迭代太慢，不能动态更新，且不能跨平台 纯Web页，有很功能无法实现，有些动画效果实现其体验太差 整体框架结构图 WebView加载流程 在Step1里有两个作用： 可以拦截html请求，对Html请求进行白名单的判断，只有规定域名的请求才能通过 转发一些如拨打电话请求，如tel:xxx 在Step2里主要是显示Loading加载框 Step3：shouldInterceptRequest() 此方法在Api为11时才有，即3.0以后才有此方法，所以在2.x系统里，无法劫持资源请求 主要用于拦截资源请求，让其走本地资源缓存，实现Native资源缓存机制 Step4：onPageFinished()要等所有的资源都加载完成后，才会进行回调，但此时，界面早已经渲染出来了。 Loading界面消失的机制： 在html界面渲染完后，js马上回调一个PageFinished的Action通知Native，提前消失掉Loading界面 如果没有等到PageFinished的Action，就在onPageFinished()方法里，把Loading界面消失掉 跳转协议现在的跳转协议是一个json格式，如下所示：1234567&#123; \"action\":\"loadpage\", \"pagetype\":\"link\", \"url\":\"http://xxxx\", \"title\":\"标题\" \"xxx\":\"\"&#125; 由于web页的Title是Native实现的，所以其标题需要从跳转协议里得到。 建议使用URL来做跳转协议，如下所示：1jump://action/pagetype?url=xxx&amp;title=xxx 好处：外部调起时，其协议就可以统一 html拦截机制Native实现缓存的思路是：通过shouldInterceptRequest()拦截html的请求。 js,css,image拦截机制机制和Html的一致，都是通过shouldInterceptRequest()拦截请求。 但并不是所有的请求都会进行拦截走缓存，满足如下两种规则走缓存： 标准方式，通过在URL后面添加cachevers参数，如下所示： 1http://xxx/xxx?cachevers=xx cdn的方式，URL满足cdn的格式也会走缓存，如下所示： 1http://xxx/xxx_v版本号.xx 注意：整个缓存框架里，只认第一种格式，第二种cdn格式，会在shouldInterceptRequest()方法里进行转化为第一种格式，请求时，再转化为第二种格式 html,js,css,image的缓存框架异步加载图片虽然shouldInterceptRequest()方法是在后台线程里执行的，但如果直接在此方法里，请求图片资源，那所有的图片资源都将是同步的方式加载，影响最终的加载速度，也会阻塞shouldInterceptRequest()方法的执行，从而阻塞webview的渲染。 解决思路：创建新的线程来请求图片资源，马上返回shouldInterceptRequest()方法，但如何实现呢？通过查看WebView的源码，找到了一种方式：使用管道，代码如下：12345678@Overridepublic WebResourceResponse shouldInterceptRequest(WebView view, String url) &#123; ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe(); // 创建一个管道，一个出口，一个入口 new TransferThread(context, uri, new ParcelFileDescriptor.AutoCloseOutputStream(pipe[1])).start(); AssetFileDescriptor assetFileDescriptor = new AssetFileDescriptor(pipe[0], 0, AssetFileDescriptor.UNKNOWN_LENGTH); FileInputStream in = assetFileDescriptor.createInputStream(); return new WebResourceResponse(type, \"utf-8\", in);&#125; 缓存资源的版本号管理缓存资源是通过其版本号来更新的，那资源的版本号应该存在哪里了？最直接的解决办法是：创建一个数据库，里面存储文件名与版本号的对应关系。我们最早也是这样实现的，这样会带来维护成本，还有其出错的概率。 最好的方案：把版本号与缓存文件存储在一起。 实现思路：不管缓存文件是文本文件，还是图片，在文件的开始位置写入一些Byte字节，这些Byte字节就存储了对应的版本号。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247/** * Created by maolei on 2015/9/8. */public class ExtraDiskCache&#123; private static final String FUNCTION = \"diskCache\"; /** Magic number for current version of cache file format. */ private static final int CACHE_MAGIC = 0x20150908; private static final String NO_VALUE = \"null\"; /** The root directory to use for the cache. */ private final File mRootDirectory; // TODO clear file public ExtraDiskCache(File rootDirectory)&#123; mRootDirectory = rootDirectory; if(!mRootDirectory.exists())&#123; mRootDirectory.mkdirs(); &#125; &#125; private File getFile(String fileName)&#123; return new File(mRootDirectory, fileName); &#125; public boolean save(String fileName, Map&lt;String, String&gt; extraInfo, InputStream in)&#123; BufferedOutputStream fos = null; // network inputstream need temp file; File tempFile = getFile(fileName + \"_temp\"); try&#123; fos = new BufferedOutputStream(new FileOutputStream(tempFile)); if(extraInfo != null &amp;&amp; extraInfo.size() &gt; 0)&#123; boolean success = writeHeader(fos, extraInfo); if(!success)&#123; throw new IOException(); &#125; &#125; byte[] buf = new byte[1024]; int len; while ((len = in.read(buf)) &gt; 0) &#123; fos.write(buf, 0, len); &#125; fos.flush(); File cacheFile = getFile(fileName); if(cacheFile.exists())&#123; cacheFile.delete(); &#125; tempFile.renameTo(cacheFile); return true; &#125;catch (IOException e)&#123; LOGGER.k(FUNCTION, \"write data error\", e); &#125;finally &#123; try &#123; if(in != null)&#123; in.close(); &#125; if(fos != null)&#123; fos.close(); &#125; if(tempFile.exists())&#123; tempFile.delete(); &#125; &#125;catch (IOException e)&#123; LOGGER.k(FUNCTION, \"close stream error\", e); &#125; &#125; return false; &#125; public Map&lt;String, String&gt; getInfo(String fileName)&#123; BufferedInputStream bis = null; try&#123; bis = new BufferedInputStream(new FileInputStream(getFile(fileName))); return readHeader(bis); &#125;catch (IOException e)&#123; LOGGER.k(FUNCTION, \"getInfo error\", e); &#125;finally &#123; try &#123; if(bis != null)&#123; bis.close(); &#125; &#125;catch (IOException e)&#123; &#125; &#125; return null; &#125; public InputStream getContentStream(String fileName)&#123; try&#123; File file = getFile(fileName); BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); if(readHeader(bis) != null)&#123; // current file has extra info, so return unread input stream return bis; &#125; // current file is normal file, return origin input stream bis.close(); return new BufferedInputStream(new FileInputStream(file)); &#125;catch (IOException e)&#123; &#125; return null; &#125; private Map&lt;String, String&gt; readHeader(InputStream in)&#123; try &#123; int magic = readInt(in); if (magic != CACHE_MAGIC) &#123; throw new IOException(); &#125; return readStringStringMap(in); &#125;catch (IOException e)&#123; &#125; return null; &#125; private boolean writeHeader(OutputStream out, Map&lt;String, String&gt; extraInfo)&#123; try&#123; writeInt(out, CACHE_MAGIC); writeStringStringMap(extraInfo, out); return true; &#125;catch (IOException e)&#123; return false; &#125; &#125; /** * Simple wrapper around &#123;@link java.io.InputStream#read()&#125; that throws EOFException * instead of returning -1. */ private static int read(InputStream is) throws IOException &#123; int b = is.read(); if (b == -1) &#123; throw new EOFException(); &#125; return b; &#125; static void writeInt(OutputStream os, int n) throws IOException &#123; os.write((n &gt;&gt; 0) &amp; 0xff); os.write((n &gt;&gt; 8) &amp; 0xff); os.write((n &gt;&gt; 16) &amp; 0xff); os.write((n &gt;&gt; 24) &amp; 0xff); &#125; static int readInt(InputStream is) throws IOException &#123; int n = 0; n |= (read(is) &lt;&lt; 0); n |= (read(is) &lt;&lt; 8); n |= (read(is) &lt;&lt; 16); n |= (read(is) &lt;&lt; 24); return n; &#125; static void writeLong(OutputStream os, long n) throws IOException &#123; os.write((byte)(n &gt;&gt;&gt; 0)); os.write((byte)(n &gt;&gt;&gt; 8)); os.write((byte)(n &gt;&gt;&gt; 16)); os.write((byte)(n &gt;&gt;&gt; 24)); os.write((byte)(n &gt;&gt;&gt; 32)); os.write((byte)(n &gt;&gt;&gt; 40)); os.write((byte)(n &gt;&gt;&gt; 48)); os.write((byte)(n &gt;&gt;&gt; 56)); &#125; static long readLong(InputStream is) throws IOException &#123; long n = 0; n |= ((read(is) &amp; 0xFFL) &lt;&lt; 0); n |= ((read(is) &amp; 0xFFL) &lt;&lt; 8); n |= ((read(is) &amp; 0xFFL) &lt;&lt; 16); n |= ((read(is) &amp; 0xFFL) &lt;&lt; 24); n |= ((read(is) &amp; 0xFFL) &lt;&lt; 32); n |= ((read(is) &amp; 0xFFL) &lt;&lt; 40); n |= ((read(is) &amp; 0xFFL) &lt;&lt; 48); n |= ((read(is) &amp; 0xFFL) &lt;&lt; 56); return n; &#125; static void writeString(OutputStream os, String s) throws IOException &#123; byte[] b = s.getBytes(\"UTF-8\"); writeLong(os, b.length); os.write(b, 0, b.length); &#125; static String readString(InputStream is) throws IOException &#123; int n = (int) readLong(is); byte[] b = streamToBytes(is, n); return new String(b, \"UTF-8\"); &#125; static void writeStringStringMap(Map&lt;String, String&gt; map, OutputStream os) throws IOException &#123; if(map == null || map.size() == 0)&#123; return; &#125; writeInt(os, map.size()); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; writeString(os, entry.getKey()); String value = entry.getValue(); if(TextUtils.isEmpty(value))&#123; writeString(os, NO_VALUE); &#125;else&#123; writeString(os, entry.getValue()); &#125; &#125; &#125; static Map&lt;String, String&gt; readStringStringMap(InputStream is) throws IOException &#123; int size = readInt(is); if(size &lt;= 0)&#123; return null; &#125; Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;(size); for (int i = 0; i &lt; size; i++) &#123; String key = readString(is).intern(); String value = readString(is).intern(); if(NO_VALUE.equals(value))&#123; value = \"\"; &#125; result.put(key, value); &#125; return result; &#125; /** * Reads the contents of an InputStream into a byte[]. * */ private static byte[] streamToBytes(InputStream in, int length) throws IOException &#123; byte[] bytes = new byte[length]; int count; int pos = 0; while (pos &lt; length &amp;&amp; ((count = in.read(bytes, pos, length - pos)) != -1)) &#123; pos += count; &#125; if (pos != length) &#123; throw new IOException(\"Expected \" + length + \" bytes, read \" + pos + \" bytes\"); &#125; return bytes; &#125;&#125; 相关的类 WebResLoader：资源加载类，负责：异步加载，同步加载 WebResCacheManager：资源管理类，负责：资源保存，加载，资源版本管理 交互框架现在的交互方式有： 通过webview的addJavascriptInterface()方法交互 优点：简单，Js可以获取返回值，从Api 1开始支持。 缺点：不安全，js可以通过此漏洞调用用户手机里的很多功能 使用会在shouldInterceptRequest()方法交互 优点：安全 缺点：从Api11(即3.0)才支持，不支持js获取返回值 交互协议如下：1234&#123; \"action\":\"xxx\", \"xxx\":\"xxx\"&#125; 使用的是json协议，其中的action区分事件类型 具体的交互框架： 每一个Action协议会有对应的Bean, Parser, ActionCtrl。都是一一对应的 ActionCtrl都在在具体的Fragment载体页进行注册，只有先注册过的Action，才会有相应的处理 在MessageBaseFragment里注册的Action为通用Action，所有的载体页都支持 Bean对象合法检测：在action协议解析完成后会生成一个Bean对象，所有的Bean对象都继承自ActionBean基类，在ActionBean类中新增checkWebAction()方法，以及check()抽象方法，由子类实现check()方法实现子类自己的协议检测。checkWebAction()方法执行所有ActionBean的通用检测，并在checkWebAction()方法中调用check()方法，执行子类自检。 WebView的载体页 按业务分，创建了不同的载体页，即有多个MessageBaseFragment的子类。（58当前使用的方式） 优点：App开发载体页简单，单个载体页不会变的非常庞大，易于维护 缺点： 载体页过多，前端人员在写跳转协议时，要区分跳转到哪个web载体页 每个载体页支持的action协议是不一样的，造成很多不兼容问题，影响了后期的扩展性 维护成本加大了 一个载体页，支持所有的Action协议，支持所有的业务。（Hybrid二期会改为此种方式） 优点和缺点刚好和上面的方式相反，推荐使用此种方式 Cookie，Header通过webview加载html的方式，有下面两种方法：12345// 直接加载urlwebview.loadUrl(String url) // 在加载url时，要添加header头信息，注意：此方法在2.2时，才添加了webview.loadUrl (String url, Map&lt;String, String&gt; additionalHttpHeaders) 通过上面的方法直接加载Html页面时，会自动把cookie添加，那我们带一些参数给Server的方式就有两种： 通过cookie来带数据 2.2以后，通过Header带数据 经验： 两个同时都带，cookie和header都带相同的数据 在有一些Android手机里，其cookie总是上传不成功，通过抓包发现根本没有cookie信息。（之后证实发现用户其他app也无法使用cookie） Header是完全可以保证数据不丢失的方式，但由于javascript发出的请求，都无法带上header，所以还是要使用cookie 白名单所谓的白名单是指：不在白名单内的请求，不进行加载，或者弹出一个Dialog，提示用户。 实现思路： 本地有一个白名单列表，可以更新此列表。注意：列表里指保存域名 在WebViewClient的shouldOverrideUrlLoading()方法里，进行拦截判断。注意：判断时，要考虑一级域名，二级域名等等。 WebView添加额外功能WebView默认情况下缺少很多功能： 不能图片上传 不能进行文件下载 不能拨打电话等等调用系统其他组件 图片上传功能：分为两种，一种通过相册选择，再上传；一种是拍照后，再上传。这两种都能支持，方法可以直接搜索就可以了。问题：有部分手机无法调启上传，机型支持问题，解决方案：通过Action，由native来做上传 文件下载：原生不支持下载的URL，把下载URL，支持转发到浏览器，进行下载。最好不要支持url支持下载。58现在不支持 调用通用组件：在shouldOverrideUrlLoading()进行通用处理，如下所示：12345678910111213public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; try &#123; if (url.startsWith(\"http:\") || url.startsWith(\"https:\") || url.startsWith(\"file:\")) &#123; // Html请求 &#125; // 其他的通用处理 view.getContext().startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url))); return true; &#125; catch (Exception e) &#123; LOGGER.e(TAG, null, e); &#125; return false;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://handsomeliuyang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://handsomeliuyang.github.io/tags/Android/"},{"name":"开发模式","slug":"开发模式","permalink":"https://handsomeliuyang.github.io/tags/开发模式/"}]},{"title":"Android收藏的好文章","slug":"2016-03-22-Android收藏的好文章","date":"2016-03-22T02:42:49.000Z","updated":"2016-10-15T10:03:37.000Z","comments":true,"path":"2016/03/22/2016-03-22-Android收藏的好文章/","link":"","permalink":"https://handsomeliuyang.github.io/2016/03/22/2016-03-22-Android收藏的好文章/","excerpt":"","text":"工具类 这些小工具让你的Android开发更高效 分析内存溢出：LeakCanary 分析ANR异常：BlockCanary 反编译工具 调试Android应用 动画 Android自绘动画实现与优化实战——以Tencent OS录音机波形动画为实例&amp;version=11020201&amp;pass_ticket=iySX2uzbIVQ3hWQPwrlLeaRxz4EgosUgwZ2MCUEZd4Q0KD01oC00QE3N0zbNuRoL)","categories":[{"name":"Android","slug":"Android","permalink":"https://handsomeliuyang.github.io/categories/Android/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"https://handsomeliuyang.github.io/tags/收藏/"},{"name":"Android","slug":"Android","permalink":"https://handsomeliuyang.github.io/tags/Android/"}]},{"title":"Markdown常用语法","slug":"markdown常用语法","date":"2016-03-17T05:05:47.000Z","updated":"2016-08-13T08:21:13.000Z","comments":true,"path":"2016/03/17/markdown常用语法/","link":"","permalink":"https://handsomeliuyang.github.io/2016/03/17/markdown常用语法/","excerpt":"","text":"标题 引用 序列 注意： 序列的缩进使用Tab键或四个空格 换行换行就直接空一行就行 代码 注意： 如果代码里有空行，会影响markdown排版，可以使用字符 ”[空行]“ 来替换 链接 图片 注意： hexo里添加图片的方式：在source文件下创建一个img的文件夹，在md里引用的路径：/img/xxx.png 加粗、斜体","categories":[{"name":"hexo","slug":"hexo","permalink":"https://handsomeliuyang.github.io/categories/hexo/"}],"tags":[]},{"title":"托管博客到Coding","slug":"托管博客到Coding","date":"2016-03-16T14:01:41.000Z","updated":"2016-08-13T08:21:13.000Z","comments":true,"path":"2016/03/16/托管博客到Coding/","link":"","permalink":"https://handsomeliuyang.github.io/2016/03/16/托管博客到Coding/","excerpt":"","text":"原因github上push代码，访问速度都比较慢，所以决定迁移到国内的Git托管服务：Coding 迁移Repository步骤： 进入Coding站点：https://coding.net，申请帐号 创建一个Project，如下设置： 项目名称为用户名 设置为公开 使用【导入仓库】功能，把github上的仓库导入进来 从master分支创建一个coding-pages分支，并设置其为默认分支 并已coding-pages为分支，打开Pages服务 即可以访问自己的博客：http://用户名.coding.me 修改hexo里的_config.yml文件里的布署，修改如下：1234deploy: type: git repository: git@git.coding.net:handsomeliuyang/handsomeliuyang.git branch: coding-pages","categories":[{"name":"hexo","slug":"hexo","permalink":"https://handsomeliuyang.github.io/categories/hexo/"}],"tags":[]},{"title":"Gradle分享","slug":"Gradle分享","date":"2016-03-16T10:15:29.000Z","updated":"2016-08-13T08:21:13.000Z","comments":true,"path":"2016/03/16/Gradle分享/","link":"","permalink":"https://handsomeliuyang.github.io/2016/03/16/Gradle分享/","excerpt":"","text":"Gradle是什么 Gradle是一个自动化构建工具，用来替换ant及maven。 Gradle的特点： 具有表达性的语言和强大的API（Gradle的表达性语言称为DSL） Gradle就是Groovy，但高于Groovy 灵活的约定（所有的配置属性都有其默认值，但也可以全部进行配置） 和其他构建工具的集成（可以与Ant，Maven集成，迁移成功比较低） 强大的依赖管理（Gradle没有其专有的依赖管理工具，但其兼容Ivy及Maven） 扩展非常方便 Groovy与Java的关系： Gradle的脚本里的语法Gradle脚本例子脚本build.gradle, 如：123task hello1 &lt;&lt; &#123; println 'hello1'&#125; 上面的代码使用DSL定义了一个Task 问题：什么是DSL，其与groovy的关系是什么？ 解答： DSL分为两类：外部DSL和内部DSL。外部DSL是一种独立的可解析的语言，举一个最常见的是例子，SQL，它专注于数据库的操作。内部DSL是通用语言所暴露的用来执行特定任务的API，它利用语言本身的特性，将API以特殊的形式（或者格式）暴露出来的，如Gradle。 Gradle是内部DSL，其实就是一套API，对应其Groovy的对象。定义DSL的目的，是使Gradle看上去更像脚本语言。 Gradle基于Groovy但大于Groovy，它是经过“定制”的Groovy，是经过“定制”的面向对象语言，所以，由始至终，Gradle都离不开对象这个概念。 上面的Gradle脚本转化为对应的Groovy对象来理解： 有一个Project对象，其有一个task方法，返回一个Task对象，如Project.task(String name) hello1是一个String的参数 符号“&lt;&lt;”是操作符重载。Task.leftShift(Closure action)，用来给task的action列表中添加一个action。 转化为Groovy代码的写法：123task(\"hello1\").leftShift(&#123; println 'hello world'&#125;) Gradle的DSL与API对应既然DSL是一套API，用来对应Groovy里的对象的，那主要有哪些对象了。 1. DSL文档：https://docs.gradle.org/current/dsl/，Java文档：https://docs.gradle.org/current/javadoc/ 2. Gradle对象，运行脚时，第一个创建的对象 3. 每个build.gradle脚本对应Project对象 4. 每个task都是interface Task的子类，上面创建的hello1是DefaultTask的对象 5. 在build.gradle里可以使用DSL写代码，也可以使用Java语法或Groovy语法来写代码。 定义Task的几种方法 使用DSL方式来定义 特点： 都是DefaultTask类的子类 都是相当于调用doLast()方法，把闭包传入一个队列里，当task的方法执行完后，再进行调用，和Android的Hander比较类似。 注意：上面都不是方法定义，都是方法调用， 自定义Task类和方法 特点： 由于Gradle使用的是Groovy，所以只有在定义类时，才能定义方法，其他DSL里的，都是调用方法。 由于Gradle是一种脚本语言，其运行时，不用手动将java类转化为class文件，才能执行，而是可以直接编译，解释执行。 Android-Gradle插件相关： Android插件的DSL：http://google.github.io/android-gradle-dsl/ Gradle的生命周期gradle运行例子当我们有一个build.gradle的脚本，内容如下：123task helloWorld &lt;&lt; &#123; println 'hello, world'&#125; 执行Task:12$ gradle -q helloWorldhello, world Gradle的底层运行过程： Task相关 为了方便对编译过程进行干预，每个Task都有一个doFirst()和doLast()方法，可以不断的给Task的两个执行对列添加闭包对象，等Task执行时，再依次执行，如下图所示： 可以访问DefaultTask里的任何属性，在Groovy里，属性会自动创建对应的getXXX()，setXXX()方法 默认创建的task对象，都是DefaultTask类的对象，可以修改其对象类型，如下： Task之间可以创建其依赖，等特其他Task执行完之后，再进行执行，定义依赖： 理解Task的配置阶段及执行阶段 task的inputs及outputs 判断一个Task是否执行，是通过判断其inputs及outputs是否有改动，如果有改动时，才会执行。定议Task的的inputs和outputs是在定义Task类时，通过注解添加的，对应DefaultTask里有两个属性：inputs: TaskInputs outputs: TaskOutputs通过gradle xxx -d可以看到task的inputs及outputs 依赖管理 为什么要引入依赖管理？ 没有引入依赖管理时，我们会遇到的一些问题： Eclipse开发Android阶段，对于jar的引入，需要手动去下载 依赖的jar如果还关系其他jar，也需要进行引入 如果jar有变动时，通知使用方去修改，也比较麻烦 经常出现依赖jar版本不合适的问题依赖管理就是为了解上面这些问题，而引入的。 Gradle的依赖管理，Maven仓库，本地依赖缓存 总结： Android-Cradle插件的Maven仓库地址：http://mvnrepository.com/artifact/com.android.tools.build/gradle 58同城的Maven仓库地址：http://artifactory.58corp.com:8081/artifactory/webapp/browserepo.html?6 本地的依赖缓存的地址：.gradle/caches/modules-2/files-2.1 查看本地缓存地址的方法：输出configurations里的dependency对象，就可以知道其保存地址 通过gradle xxx -d输出完整地址，仔细去读里面的日志，也可以知道其保存地址 外部模块依赖 外部模块依赖的属性： group：用来标识一个公司，组织或者项目，通常的做法是：公司的域名反写。如：com.wuba.wuxian.lib name：一个模块的名称，一个group内要唯一。如：WubaCommonsLib version：版本号，如：2.0.0，3.6.3-Final，2.0.0-SNAPSHOT等等。所以版本号不是int类型，是String类型 classifier：如果group,name,version都一样时，用于区分的。如jar的源码，javadoc等等如例子： com.wuba.wuxian.lib:WubaCommonsLib:2.0.0-SNAPSHOT com.wuba.wuxian.lib:WubaCommonsLib:2.0.0-javadoc com.wuba.wuxian.lib:WubaCommonsLib:2.0.0-sources 依赖冲突的解决方案 冲突出现的情况 a库和b库都关系同一个c库解决方案：gradle的依赖管理会自动使用最新的c库，不会使用两次c库 a库关联b库，同时关联c的源码，b库关系c库的aar问题原因：c的源码库及c库的aar不是同一个库，会当作不同的库进行处理，因为其group不一样解决方案： 只引入b库的aar，不引入b库的关联库c，如下所示： 使用排除法，排除b库的c库就行，如下所示： 更多的配置文档：https://docs.gradle.org/current/javadoc/里的DependencyHandler 灵活的版本号及本地缓存更新 如果想一直使用最新版本，可以使用动态版本本声明：com.wuba.wuxian.lib:WubaCommonsLib:2.0.0+，但希望不要这样使用，如果最新的版本，其兼容有问题，这样会影响现有代码运行。 如果正在开发调试WubaCommonsLib期间，这时，定义版本号时，可以使用快照版本号，-SNAPSHOT。把版本号定义为-SNAPSHOT时，gradle的依赖管理，会使用最新的快照库 如果本地版本库有缓存后，如果想使用最新的依赖版本，这时，就要修改本地缓存策略，如下所示： 参与文档： Gradle深入与实战：http://benweizhu.github.io/blog/2015/03/31/deep-into-gradle-in-action-6/ 《实战Gradle》","categories":[{"name":"Android","slug":"Android","permalink":"https://handsomeliuyang.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://handsomeliuyang.github.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"https://handsomeliuyang.github.io/tags/Gradle/"}]},{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2016-03-16T06:08:36.000Z","updated":"2016-08-13T08:21:13.000Z","comments":true,"path":"2016/03/16/Hexo搭建个人博客/","link":"","permalink":"https://handsomeliuyang.github.io/2016/03/16/Hexo搭建个人博客/","excerpt":"","text":"搭建过程 Github配置 在Github上申请一个帐号 创建一个repository，其命名规则有两种 &lt;你的用户名&gt;.github.io // 那你的博客地址就是 http://&lt;你的用户名&gt;.github.io 推荐 &lt;任意名称&gt; // 那你的博客地址将是：http://&lt;你的用户名&gt;.github.io/&lt;任意名称&gt; 使用ssh连接，配置ssh的公钥和私钥，以后连接github不用再输入密码 Hexo安装 请按最新官网安装并配置Hexo，具体请看：https://hexo.io/ 使用如下命令，搭建本地Server：123hexo clean // 清除刚刚创建的静态web网页hexo g // hexo generator的缩写，生成静态web网页，生成的目录是：publichexo s // hexo server的缩写，生成本地web服务器，可以访问，查看效果 开发环境 下载webstorm 给webstorm安装markdown插件 通过webstorm加载hexo Hexo的目录结构 Hexo的配置 在_config.yml里设置如下参数： title subtitle description author email language 在_config.yml里配置github的服务器及主分支： 1234deploy: type: git repository: git@github.com:xxx branch: master 在_config.yml里配置主题和对css文件等等的压缩 123theme: jacman // 这个是我使用的主题，你可以在网上下载更多的主题stylus: compress: true // 对样式文件进行压缩 按官网教程安装Hexo后，执行hexo d命令会报错，是由于缺少Module库，执行下面的命令： 1npm install hexo-deployer-git --save 安装之后，就可以执行hexo d进行部署了 写博客 使用如下命令创建新的文章： 1hexo new &quot;文章名称&quot; 在source文件下，创建一个存放图片目录，如img，在文章里引用的地址为：/img/图片名 在目录source/_posts目录下找到文件，并编辑 文章可以设置categories(类别)和tags(标签)，注意：tags下面只能是3个横线，多了少了都不行 查看效果12345hexo cleanhexo ghexo s[空行]hexo d // hexo deployer的缩写 发布到Github Hexo备份使用Github来备份 在github上创建一个hexo的分支 把本地的hexo项目上传到hexo分支里，但注意配置.gitignore文件，如下： 12345678.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.idea 添加新功能 改主题，我使用的是jacman 添加关于，使用如下命令 1hexo new page &quot;about&quot; // 这样创建md文件，才能使用/about来引用到 添加百度统计，用于统计网站流量 添加站内搜索 添加评价，推荐使用多说 添加百度搜索、google搜索 添加sitemap.xml，供搜索引擎的爬虫使用 hexo发布新文章方法一： 创建文章，命令如下： 1hexo new &quot;文章名称&quot; 在source/_posts目录下，就会创建此文章，编译完成后，部署，命令如下： 12hexo cleanhexo d -g // 相当于先执行hexo g 再执行hexo d 方法二： 新创建草稿，命令如下： 1hexo new draft &quot;文章名称&quot; 在source/_drafts目录下，会创建相应的文章，编写文章，草稿文章默认情况下，不会被部署到站点里 把草稿发布为文章，命令如下：1hexo publish &quot;草稿文章名称&quot; F&amp;Q图片支持https://codefalling.com/2015/12/19/no-pains-with-hexo-local-image/","categories":[{"name":"hexo","slug":"hexo","permalink":"https://handsomeliuyang.github.io/categories/hexo/"}],"tags":[]},{"title":"hexo理解","slug":"hexo理解","date":"2016-03-16T03:03:16.000Z","updated":"2016-08-13T08:21:13.000Z","comments":true,"path":"2016/03/16/hexo理解/","link":"","permalink":"https://handsomeliuyang.github.io/2016/03/16/hexo理解/","excerpt":"","text":"Hexo是什么 A fast, simple &amp; powerful blog framework, powered by Node.js. 基于Node.js的一个快速、简洁且高效的博客框架。 我理解的Hexo是： 是一个Node.js的命令行脚本工具 一个把markdown编译为html页面，生成一个静态Web网站的静态博客框架 命令行脚本工具使用Node.js除了用来开发Web应用外，还可以用于开发命令行脚本工具，Hexo就是一个使用Node.js开发命令行脚本工具：1npm install XXX -g // 脚本Module只能通过全局方式添加 关于Nodejs开发命令行工具的教程：使用Node写命令行工具 静态博客框架Hexo的框架使用node.js，把markdown, ejs翻译为纯Html页面，这些纯Html页面只需要布署到Web服务器上就行了。 Hexo的源码，官网，Module Hexo的源码：https://github.com/hexojs/hexo Hexo的官网：https://hexo.io/ Hexo在npm上的Module：https://www.npmjs.com/package/hexo Hexo版本Hexo现在的版本主要有2.x及3.x，这两个版本有比较大的差别，其主要差别如下： 3.x里多了hexo-cli模块，从hexo里分离了，其中全部是命令行的工具。// 这个就是我之前想不通的，为什么会有如下两种： 12npm install hexo -g // 这个是2.x的安装方式，不过3.x也可以用npm install hexo-cli -g // 这个就是3.x的标准安装方式 3.x里把hexo模块分为Generators, deployers, server几种模块 // 这就是为什么在2.x里，可以直接使用hexo deployer，而在3.x里你要先安装deployers的模块，才能执行hexo deployer 更多差别，请查看：https://github.com/hexojs/hexo/wiki/Breaking-Changes-in-Hexo-3.0 特别注意：有些themes主题只支持hexo 2.x，要注意选择。 Hexo与Github的关系 Hexo会生成一个静态的web网站 Github Pages就是相当于一个web服务器 Github本身的git相当于FTP命令，让我们把web网站资源上传到web服务器上","categories":[{"name":"hexo","slug":"hexo","permalink":"https://handsomeliuyang.github.io/categories/hexo/"}],"tags":[]}]}